<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Re：从零开始的领域驱动设计</title>
    <url>/2019/08/11/DDD/</url>
    <content><![CDATA[<p>领域驱动设计(Domain-driven design)，缩写为DDD。以领域设计为驱动，构建整一个系统。</p>
<p>这个设计思想是在微服务开始流行时逐渐变得火爆的，因为其设计理念非常适合分布式的微服务拆分。</p>
<span id="more"></span>

<blockquote>
<p>我声明一点，本文章其实都是东拼西凑的，里面所表达的仅仅是个人的理解（我没有读完ddd那本书）</p>
</blockquote>
<h1 id="通用语言-Ubiquitous-Language"><a href="#通用语言-Ubiquitous-Language" class="headerlink" title="通用语言(Ubiquitous Language)"></a>通用语言(Ubiquitous Language)</h1><p>通用语言其实就是把模型通过大家都能够理解的语言表达出来。</p>
<p>通常我们在开发业务的过程中都是先去调研，了解其业务的具体细节，并商讨大致的程序设计，然后经过开发人员转化成为代码，在这个过程中交流是单向性的，直到下一次需要展示或者有理解出现错误时才会与客户或者是业务人员再次交流。</p>
<p>而业务人员那边通常也只能通过表面的程序看问题，无法理解其实际运作是否符合业务人员所想，这可能将导致程序在错误的方向上越走越远</p>
<p>领域驱动设计是需要建立一个通用语言的，这需要领域专家(即对这些业务整体非常熟悉的人)与开发人员一同参与</p>
<p>我们需要把程序设计上的事情通过一个通用的语言表述出去使领域专家能够理解我们是如何通过程序设计业务的，而领域专家也同样需要把那些专业名词，业务场景用通用语言描述出来</p>
<p>当我们有了通用语言后，我们就能够在建立领域对象的时候听取专家的意见，同时能够让专家理解领域对象是否符合他们的预期  </p>
<p>而形成通用语言是不容易的，因为其答案并不唯一，不同的人会有不同的理解，从而导致不同的答案。但我们可以试着从UML或是伪代码着手</p>
<p><a href="http://note.youdao.com/noteshare?id=3834bfbae566164a48b0df825fc8134d&sub=B24036AF24534B79875E2C0B5D4C886F">航运例子</a></p>
<h1 id="层结构-Layered-Architecture"><a href="#层结构-Layered-Architecture" class="headerlink" title="层结构(Layered Architecture)"></a>层结构(Layered Architecture)</h1><p><img src="/.moe//p29.png" alt="Layered Architecture"></p>
<ul>
<li>User Interface<br>负责向用户展现信息，并且会解析用户行为，即常说的展现层。</li>
<li>Application Layer<br>应用层没有任何的业务逻辑代码，它很简单，它主要为程序提供任务处理。</li>
<li>Domain Layer<br>这一层包含有关领域的信息，是业务的核心，领域模型的状态都直接或间接（持久化至数据库）存储在这一层。</li>
<li>Infrastructure Layer<br>为其他层提供底层依赖操作。</li>
</ul>
<h1 id="模型关系图-Model-Driven-Design"><a href="#模型关系图-Model-Driven-Design" class="headerlink" title="模型关系图(Model-Driven Design)"></a>模型关系图(Model-Driven Design)</h1><p><img src="/.moe//p28.png" alt="Model-Driven Design"></p>
<h2 id="服务-Services"><a href="#服务-Services" class="headerlink" title="服务(Services)"></a>服务(Services)</h2><p>当我们在分析某一领域时，一直在尝试如何将信息转化为领域模型，但并非所有的点我们都能用Model来涵盖。对象应当有属性，状态和行为，但有时领域中有一些行为是无法映射到具体的对象中的，我们也不能强行将其放入在某一个模型对象中，而将其单独作为一个方法又没有地方，此时就需要服务</p>
<h2 id="工厂-Factories"><a href="#工厂-Factories" class="headerlink" title="工厂(Factories)"></a>工厂(Factories)</h2><p>在大型系统中，实体和聚合通常是很复杂的，这就导致了很难去通过构造器来创建对象。工厂就决解了这个问题，它把创建对象的细节封装起来，巧妙的实现了依赖反转。当然对聚合也适用（当建立了聚合根时，其他对象可以自动创建）</p>
<h2 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库(Repository)"></a>仓库(Repository)</h2><p>仓库封装了获取对象的逻辑，领域对象无须和底层数据库交互，它只需要从仓库中获取对象即可。仓库可以存储对象的引用，当一个对象被创建后，它可能会被存储到仓库中，那么下次就可以从仓库取。如果用户请求的数据没在仓库中，则会从数据库里取，这就减少了底层交互的次数</p>
<h2 id="边界上下文-Bounded-Context"><a href="#边界上下文-Bounded-Context" class="headerlink" title="边界上下文(Bounded Context)"></a>边界上下文(Bounded Context)</h2><p>简单来说就是定义该领域模型的适用范围以及使用场景。</p>
<p>可以这样理解：</p>
<ul>
<li><p>边界(Bounded)<br>即有边界的，表示领域模型有边界；这个边界定义了模型的适用范围，以便让负责该模型的团队知道什么该在模型中实现，什么不该；</p>
</li>
<li><p>上下文(Context)<br>即领域模型的产生是在某个上下文中产生的；上下文是一个和环境相关的概念。比如一次头脑风暴会议大家达成了一个模型，那这次会议的讨论就是该模型的上下文；比如某本书中谈到了某个东西，那这个东西的上下文就是那本书，那个东西要有意义的前提离不开那本书这个上下文；所以，上下文是模型有意义的前提；</p>
</li>
</ul>
<h2 id="实体-Entity-和-值对象-ValueObject"><a href="#实体-Entity-和-值对象-ValueObject" class="headerlink" title="实体(Entity) 和 值对象(ValueObject)"></a>实体(Entity) 和 值对象(ValueObject)</h2><p>一言蔽之，实体大致可以理解为我们传统开发的实体，但是他具有自己的行为，而不是POJO(只具有简单的getter,setter)；值对象是指描述一个实体某个属性的对象。<br>当然，这些都是需要在上面所说的BoundedContext被指定的前提下讨论。</p>
<p>举个例子：<br>在电商系统我们现在分成两个模块，一个商品模块，一个订单模块<br>订单对象中有收货地址(address)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String address; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们把address扩展开来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    Address address; <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    String province;<span class="hljs-comment">//省</span><br>    String city;<span class="hljs-comment">//市</span><br>    String street;<span class="hljs-comment">//街道</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在Address是一个对象了，但是我们不会认为他是一个实体，因为在这个订单模块中它只是描述了订单中的收货地址而已，仅仅只是order上的一个值，几个内部的值所组合出的抽象，你完全可以把它理解为是一个Map:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    Map&lt;String, String&gt; address;<br>    <br>    <span class="hljs-comment">//address Map&#123;&quot;province&quot;:&quot;&quot;,&quot;city&quot;:&quot;&quot;,&quot;street&quot;:&quot;&quot;&#125; </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这跟java中String对象非常类似，String对象是不会进行修改的，如果你将新的一串字符串重新赋值给一个String对象，实际上等于new了一个String，地址是变化了的，不再是同一个对象。</p>
<p>所以ValueObject有这样几个特点:</p>
<ul>
<li>没有标识(唯一标识)</li>
<li>不可变(只读)</li>
<li>不具备生命周期</li>
</ul>
<h2 id="聚合-Aggregates-和-聚合-Aggregate-Root"><a href="#聚合-Aggregates-和-聚合-Aggregate-Root" class="headerlink" title="聚合(Aggregates) 和 聚合(Aggregate Root)"></a>聚合(Aggregates) 和 聚合(Aggregate Root)</h2><p><strong>聚合</strong>可以看作是多个实体之间的组合，而每个聚合都有一个根实体，叫<strong>聚合根</strong>。</p>
<p>在DDD当中，聚合外部想要访问聚合内的信息，必须通过<strong>聚合根</strong>进行访问。</p>
<ul>
<li><p>如何识别聚合和聚合根？<br>首先一个边界上下文(Bounded Context)可能包含多个聚合，每个聚合都有一个聚合根。</p>
<ol>
<li>找出哪些实体可能是聚合根</li>
<li>逐个分析每个聚合根的边界，即该聚合根应该聚合哪些实体或值对象</li>
<li>划分边界上下文</li>
</ol>
</li>
<li><p>如何确定聚合边界？<br>边界的确定法则是根据不变性约束规则（Invariant）:</p>
<ul>
<li>聚合边界内必须具有哪些信息，如果没有这些信息就不能称为一个有效的聚合</li>
<li>聚合内的某些对象的状态必须满足某个业务规则 </li>
</ul>
</li>
<li><p>如何找到聚合根？<br>如果存在一个业务操作是完全面向某个实体，那么这个实体就可能是一个聚合根</p>
</li>
</ul>
<h3 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h3><blockquote>
<p>Order（一 个订单）必须有对应的客户信息，否则就不能称为一个有效的Order<br>同理，Order对OrderLineItem有不变性约束，Order也必须至少有一个OrderLineItem(一条订单明细)，否则就不能称为一个有效的Order<br>另外，Order中的任何OrderLineItem的数量都不能为0，否则认为该OrderLineItem是无效的，同时可以推理出Order也可能是无效的。因为如果允许一个OrderLineItem的数量为0的话，就意味着可能会出现所有OrderLineItem的数量都为0，这就导致整个Order的总价为0，这是没有任何意义的，是不允许的，从而导致Order无效<br>所以，必须要求 Order中所有的OrderLineItem的数量都不能为0<br>那么现在可以确定的是Order必须包含一些OrderLineItem，那么应该是通 过引用的方式还是ID关联的方式来表达这种包含关系呢？<br>这就需要引出另外一个问题，那就是先要分析出是OrderLineItem是否是一个独立的聚合根。<br>回答了这个问题，那么根据上面的规则就知道应该用对象引用还是用ID关联了。那么OrderLineItem是否是一个独立的聚合根呢？因为聚合根意 味着是某个聚合的根，而聚合有代表着某个上下文边界，而一个上下文边界又代表着某个独立的业务场景，这个业务场景操作的唯一对象总是该上下文边界内的聚合 根。想到这里，我们就可以想想，有没有什么场景是会绕开订单直接对某个订单明细进行操作的。也就是在这种情况下，我们 是以OrderLineItem为主体，完全是在面向OrderLineItem在做业务操作。有这种业务场景吗？没有，我们对 OrderLineItem的所有的操作都是以Order为出发点，我们总是会面向整个Order在做业务操作，比如向Order中增加明细，修改 Order的某个明细对应的商品的购买数量，从Order中移除某个明细，等等类似操作，我们从来不会从OrderlineItem为出发点去执行一些业 务操作；另外，从生命周期的角度去理解，那么OrderLineItem离开Order没有任何存在的意义，也就是说OrderLineItem的生命周 期是从属于Order的。所以，我们可以很确信的回答，OrderLineItem是一个实体。</p>
</blockquote>
<h1 id="Event-Souring-事件溯源"><a href="#Event-Souring-事件溯源" class="headerlink" title="Event Souring(事件溯源)"></a>Event Souring(事件溯源)</h1><p>Event Souring是Martin Fowler提出的一种架构模式，其特点是：</p>
<ul>
<li>整个系统由事件进行驱动</li>
<li>事件是一等公民，系统的基础数据是事件，事件需要被储存在数据库中</li>
<li>业务数据只是由事件产生的视图，不一定需要存储在数据库</li>
</ul>
<p>这里展示的例子是一个银行账户经历的几个事件：创建 -&gt; 存款300 -&gt; 存款100 -&gt; 取出200<br><img src="/.moe//v2-7c6a1b0c101d8f0cf5e89716bfb4d6a1_hd.jpg" alt="Event Souring"></p>
<p>在这样的设计下，每个对象都需要经历一系列的事件才会转化成现在的状态，当我们只需要进行查询的时候，这些操作未免显得太过累赘，所以我们可以把对象的最终状态存入一个视图数据库，当需要查询的时候直接查询这个数据库即可<br><img src="/.moe//v2-35249fb2693f44bbe4bf48ea6755c55c_hd.jpg" alt="Event Souring"></p>
<h1 id="CQRS-命令查询责任分离"><a href="#CQRS-命令查询责任分离" class="headerlink" title="CQRS(命令查询责任分离)"></a>CQRS(命令查询责任分离)</h1><p>CQRS简单理解就是读写分离，但它的实现可能相对其定义要复杂些，并且通常都是会和Event Souring一起被提及<br><img src="/.moe//CQRS.jpg" alt="CQRS + Event Souring"></p>
<p>参考资料：</p>
<ul>
<li>《领域驱动设计：软件核心复杂性应对之道》  </li>
<li><a href="https://zhuanlan.zhihu.com/p/38968012">深入浅出Event Sourcing和CQRS</a></li>
<li><a href="https://www.cnkirito.moe/Re-DDD/">Re：从零开始的领域驱动设计</a></li>
<li><a href="https://www.cnkirito.moe/DDD-practice/">一个DDD指导下的实体类设计案例</a></li>
<li><a href="https://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html">DDD领域驱动设计基本理论知识总结</a></li>
<li><a href="http://newtech.club/2017/06/09/%E5%A4%9A%E7%A0%94%E7%A9%B6%E4%BA%9B%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%B0%91%E8%B0%88%E4%BA%9B%E6%A1%86%E6%9E%B6%EF%BC%881%EF%BC%89-%E8%AE%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/">多研究些架构，少谈些框架</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>CQRS</tag>
        <tag>Event Sourcing</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 JPA 的多租户实现后续</title>
    <url>/2025/09/21/JPA-based-multi-tenancy-impl-issues/</url>
    <content><![CDATA[<p>经过一段时间后，上次构思的实现发现了一些问题</p>
<span id="more"></span>
<h2 id="数据库链接的默认值"><a href="#数据库链接的默认值" class="headerlink" title="数据库链接的默认值"></a>数据库链接的默认值</h2><p>由于数据库初始化的时候必须给到一个初始配置（X 类型，Y cluster），这个没有太大问题，但是切换数据库的时候需要严谨的判断，判断目标数据库是否已配置，<br>判断目标数据库是否在在active list中，避免拿到一个default的数据库链接。</p>
<h2 id="数据ID的生成"><a href="#数据ID的生成" class="headerlink" title="数据ID的生成"></a>数据ID的生成</h2><p>ID如果是用table generator并且预取N&gt;1的id会导致切换数据库后拿的是上一个数据库的id插入，解决办法要么是预取size设置为1，要么改造默认的生成器以适配数据库切换。  </p>
<p>改在默认生成器会比较麻烦，原本的实现写了比较多的情况以及方法的抽象。</p>
<hr>
<p>待续</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/2017/04/20/Demo/</url>
    <content><![CDATA[<p>test test！！</p>
<span id="more"></span>
<h2 id="ACG"><a href="#ACG" class="headerlink" title="ACG"></a>ACG</h2><h3 id="格子裙赛高！"><a href="#格子裙赛高！" class="headerlink" title="格子裙赛高！"></a>格子裙赛高！</h3><p><img src="/.moe//COLORS_47646872_p0.jpg" alt="123"> </p>
<p><a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=47646872">カントク - COLORS(id=47646872)</a></p>
]]></content>
      <categories>
        <category>ACG</category>
      </categories>
      <tags>
        <tag>监督</tag>
        <tag>格子裙</tag>
        <tag>放学五年目</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 JPA 的多租户实现</title>
    <url>/2025/06/04/JPA-based-multi-tenancy-implementation/</url>
    <content><![CDATA[<p>在工作开发中我遇到了需要链接多个DB项目的情况，业务上以不同的医院进行请求查询，而一个cluster能够包含几个医院，一个cluster则会划分到一个DB（或schema）中，基本上可以认为不同cluster为不同的db connection，至此该项目就像是多租户上划分多个db的情况了。</p>
<span id="more"></span>
<h2 id="Requirement"><a href="#Requirement" class="headerlink" title="Requirement"></a>Requirement</h2><ul>
<li>Thread-Safe<br>基于servlet一个请求绑定一个线程</li>
<li>根据请求切换至对应数据库</li>
<li>链接多于一种类型数据库<br>由于业务还需要逐步从A数据库到B数据库，这期间一定会有链接两种数据库的情况</li>
<li>监听/定时刷新激活的数据库配置<br>即哪些cluster已转移至B数据库，哪些没有</li>
</ul>
<h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><p>由于传统Servlet为一个请求绑定住一个线程，除非自己切换不然都能够安全通过ThreadLocl来作为上下文确定当前应该切换至哪个cluster。<br>但需要注意，每个请求过来绑定的线程不一定会在请求结束后销毁，也许会被重复利用在下一个请求当中，所以需要加入一个OnePerRequestFilter在请求结束后清空ThreadLocal上下文已保证新请求绑定已有线程不被污染。<br>Btw，Reactive就要用Reactive的线程上下文了。</p>
<p>激活的数据库配置初步是定为配置文件放在minio中共各个服务读取，以达成统一配置减少线上部署人员的工作，定时刷则用timer定时跑一个task重复刷新配置文件，这里需要给到相关变量读写锁的控制，另外在初始化timer的时候要用双检锁保证exactly-once initialize(瞎掰的词，源自exactly-once delivery)。</p>
<p>而链接不同数据库，在同一种数据库下是可以直接用<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/lookup/AbstractRoutingDataSource.html">AbstractRoutingDataSource</a>做动态切换的，但你需要在事务开启前做这个事情，另外还需要注意，<code>spring.jpa.open-in-view</code>需要关闭它以避免请求过来的时候就过早开启一个session导致各种问题的发生，参考<a href="https://stackoverflow.com/questions/30549489/what-is-this-spring-jpa-open-in-view-true-property-in-spring-boot">这里</a>。<br>但需求是链接两种数据库，那么你还需要对Entity Manager做Routing来确保两种不同的数据库方言能够正运行。<br>所以下面就开始了部分源码的阅读以及调试时实际情况是如何的了。</p>
<h2 id="Learning-amp-Debug"><a href="#Learning-amp-Debug" class="headerlink" title="Learning &amp; Debug"></a>Learning &amp; Debug</h2><p>实际上，如果不希望冒着这样的风险做改动，最简单的做法就是将配置复制N分，遇到什么cluster就用什么repository，但是我们有7个cluster x 2种数据库，感觉还是太蠢了。<br>那么动态生成repository呢？我想应该是可以的，但他需要一个entitymanger，那你是不是又要自己动态生成一个entitymanager呢？然后一系列的东西就会指引到TransactionMnager上。</p>
<p>经过断点，<code>DataSource#getConnection</code>以及<code>EntityManagerFactory#createEntityManager</code>，然后你就会发现在一个Transaction内他们是只会调用一次的，而调用的地方就是<code>JpaTransactionManager#doBegin</code>，也就是进入被<code>@Transactional</code>注解的方法前，而在前面两个方法创建后，<code>EntityManager</code>会放入这次Transaction的上下文对象<code>JpaTransactionObject</code>(该对象在doGetTransaction方法生成)的<code>EntityManagerHolder</code>中，并且绑定到<code>TransactionSynchronizationManager</code>，<code>DataSource</code>则只会绑定至<code>TransactionSynchronizationManager</code>。<br>也就是说，spring事务开启后，处于事务期间你是无法切换<code>EntityMnager</code>以及<code>DataSource</code>的，除非你自定义一个<code>TransactionMnager</code>，但是如果我们自定义事务管理器可以拿两个<code>EntityManagerFactory</code>，但是<code>Repository</code>的配置中只会认一个<code>EntityManagerFactory</code>，所以最终你还是必须有一个Routing的<code>EntityManagerFactory</code>。</p>
<p>之后根据源码可以了解到实际上事务管理器没有用到太多<code>EntityManagerFactory</code>的接口，我们只需要重写<code>AbstractEntityManagerFactoryBean</code>下的<code>createNativeEntityManagerFactory</code>, <code>getNativeEntityManagerFactory</code>，这些方法都根据当前上下文的cluster以及迁移的db类型配置路由到对应的FactoryBean上就好了，一般直接拿<code>nativeEntityManagerFactory</code>就好了，<code>destroy</code>方法直接调用一边维护的所有FactoryBean就好了。</p>
<p>为什么是FactoryBean？因为这是特殊的类型，实际注入的是getObject拿到的对象，而<code>AbstractEntityManagerFactoryBean</code>的对象则会维护在<code>nativeEntityManagerFactory</code>变量上。</p>
<p>这样我们也就可以用一个repository实现需求了。</p>
<p>但是且慢，我们知道事务注解下的情况，那非事务下呢？<br>实际上这个也是最开始我有做断点了解到的，非事务下是会有一个shared相关的实例（具体忘了是啥了），他会绑定到Primary的<code>DataSource</code>,  <code>EntityManagerFactory</code>，所以这也是为什么思考方向会朝着一个单独的一个配置做Routing去。<br>Btw，务必保证有一个主要的一套配置在，不然JPA Auto Configuration不会生效。</p>
<p>至此我们就能够实现之前提出要求了。</p>
<h2 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h2><p>只重点说一下Jpa的配置，首先需要两套<code>DataSource</code>，<code>EntityManagerFactory</code>，分别为A数据库类型和B数据库类型，而<code>DataSource</code>是一个Routing到同类型不同数据库的数据源，再加入一个主要数据源Routing不同数据库类型到实际的Routing数据源，一个主要<code>EntityManagerFactory</code>并自定义实现的Routing功能就好了。融合一个大的主要数据源还有个原因是为了可以用<code>JdbcTemplate</code></p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Demo可以在<a href="https://github.com/KurenaiRyu/multi-db-demo">这里</a>看到，并且这是非常实验性的，还未跑过大量数据以及业务去验证其正确性，例如多个不同传播类型的事务互相调用互相嵌套的情况。另外<code>AbstractEntityManagerFactoryBean</code>也不是很能够确定是否这样重写几个接口就没有问题，只是目前发现<code>TransactionManager</code>没有过多使用其他接口。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx基础——Rewrite规则</title>
    <url>/2018/12/30/Nginx%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Rewrite%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>&emsp;&emsp;rewrite是nginx一个特别重要的指令，该指令可以使用正则表达式改写URI。可以指定一个或多个rewrite指令，按顺序匹配。</p>
<span id="more"></span>
<h2 id="正则匹配规则"><a href="#正则匹配规则" class="headerlink" title="正则匹配规则"></a>正则匹配规则</h2><blockquote><p>~  区分大小写匹配<br><del>* 不区分大小写匹配<br>!</del> 和 !~* 区分大小写不匹配及不区分大小写不匹配  </p>
</blockquote>

<h2 id="文件及目录匹配"><a href="#文件及目录匹配" class="headerlink" title="文件及目录匹配"></a>文件及目录匹配</h2><blockquote><p>-f和!-f 判断是否存在文件<br>-d和!-d 判断是否存在目录<br>-e和!-e 判断是否存在文件或目录<br>-x和!-x 判断文件是否可执行</p>
</blockquote>

<h2 id="rewrite基本语法"><a href="#rewrite基本语法" class="headerlink" title="rewrite基本语法"></a>rewrite基本语法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">set</span>  <br><span class="hljs-keyword">if</span>  <br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">break</span><br>rewrite<br></code></pre></td></tr></table></figure>

<h3 id="break指令"><a href="#break指令" class="headerlink" title="break指令"></a>break指令</h3><blockquote><p>使用范围：server，location，if;  </p>
</blockquote> 

<p>中断当前相同作用域的其他nginx配置。 </p>
<h3 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h3><blockquote><p>使用范围：server，location  </p>
</blockquote> 

<p>检查一个条件是否符合。If指令不支持嵌套，不支持多个条件&amp;&amp;和||处理。</p>
<h3 id="return指令"><a href="#return指令" class="headerlink" title="return指令"></a>return指令</h3><blockquote><p>格式：return code ;<br>使用范围：server，location，if;</p>
</blockquote> 

<p>结束规则的执行并返回状态码给客户端。</p>
<h3 id="set指令"><a href="#set指令" class="headerlink" title="set指令"></a>set指令</h3><blockquote><p>使用环境：server，location，if  </p>
</blockquote> 

<p>定义一个变量，并给变量赋值。变量的值可以为文本、变量或者变量的组合。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> <span class="hljs-variable">$var</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="rewrite指令格式"><a href="#rewrite指令格式" class="headerlink" title="rewrite指令格式"></a>rewrite指令格式</h2><pre><code class="hljs">rewrite regex replacement [flag]
</code></pre>
<p>flag标志位有四种：</p>
<blockquote><p>break：停止rewrite检测,也就是说当含有break flag的rewrite语句被执行时,该语句就是rewrite的最终结果。<br>last：停止rewrite检测,但是跟break有本质的不同,last的语句不一定是最终结果。<br>redirect：返回302临时重定向，一般用于重定向到完整的URL(包含http:部分)<br>permanent：返回301永久重定向，一般用于重定向到完整的URL(包含http:部分) </p>
</blockquote> 

<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>当访问的文件和目录不存在时，重定向到某个php文件</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-keyword">if</span>( !-e <span class="hljs-variable">$request_filename</span> )<br>&#123;<br>    rewrite ^/(.*)<span class="hljs-variable">$ </span>index.php last;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>目录对换 /123456/xxxx ====&gt; /xxxx?id=123456</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/(\d+)/(.+)/</span>  /<span class="hljs-variable">$2</span>?id=<span class="hljs-variable">$1</span> <span class="hljs-literal">last</span>;<br></code></pre></td></tr></table></figure>
<p>如果客户端使用的是IE浏览器，则重定向到/ie目录下</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span>( <span class="hljs-variable">$http_user_agent</span> ~ MSIE)<br>&#123;<br>    rewrite ^(.*)$ <span class="hljs-regexp">/ie/</span><span class="hljs-variable">$1</span> <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>禁止访问以/data开头的文件</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">~ ^/data</span><br>&#123;<br>    <span class="hljs-keyword">deny</span> all;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>禁止访问以.sh，.flv，.mp3为文件后缀名的文件</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">location ~ .*\.(sh|<span class="hljs-type">flv</span>|<span class="hljs-type">mp3</span>)$<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">403</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>设置某些类型文件的浏览器缓存时间</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">location ~ .*\.(gif|<span class="hljs-type">jpg</span>|<span class="hljs-type">jpeg</span>|<span class="hljs-type">png</span>|<span class="hljs-type">bmp</span>|<span class="hljs-type">swf</span>)$<br>&#123;<br>    expires <span class="hljs-number">30</span>d;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>文件反盗链并设置过期时间</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">location ~*^.+\.(jpg|<span class="hljs-type">jpeg</span>|<span class="hljs-type">gif</span>|<span class="hljs-type">png</span>|<span class="hljs-type">swf</span>|<span class="hljs-type">rar</span>|<span class="hljs-type">zip</span>|<span class="hljs-type">css</span>|<span class="hljs-type">js</span>)$ <br>&#123;<br>    valid_referers none blocked *.linuxidc.com*.linuxidc.net localhost <span class="hljs-number">208.97</span><span class="hljs-number">.167</span><span class="hljs-number">.194</span>;<br>    <span class="hljs-keyword">if</span> ($invalid_referer) &#123;<br>        <span class="hljs-built_in">rewrite</span> ^/ http://img.linuxidc.net/leech.gif;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">412</span>;<br>        break;<br>    &#125;<br>    access_log  off;<br>    root /opt/lampp/htdocs/web;<br>    expires <span class="hljs-number">3</span>d;<br>    break;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>将多级目录下的文件转成一个文件，增强seo效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">  <br>/job-123-456-789.html 指向/job/123/456/789.html<br><br>rewrite^/job-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /job/<span class="hljs-variable">$1</span>/<span class="hljs-variable">$2</span>/jobshow_<span class="hljs-variable">$3</span>.html last;<br></code></pre></td></tr></table></figure>
<p>域名跳转</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span><br>&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> jump.linuxidc.com;<br>    <span class="hljs-attribute">index</span> index.html index.htm index.php;<br>    <span class="hljs-attribute">root</span> /opt/lampp/htdocs/www;<br>    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/</span> http://www.linuxidc.com/;<br>    <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>多域名转向</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">server_name</span> www.linuxidc.comwww.linuxidc.net;<br><span class="hljs-attribute">index</span> index.html index.htm index.php;<br><span class="hljs-attribute">root</span>  /opt/lampp/htdocs;<br><span class="hljs-attribute">if</span> (<span class="hljs-variable">$host</span> <span class="hljs-regexp">~ &quot;linuxidc\.net&quot;)</span> &#123;<br>    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(.*)</span> http://www.linuxidc.com<span class="hljs-variable">$1</span>permanent;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>黑神话Gameplay</title>
    <url>/2024/09/08/black-myth-gameplay/</url>
    <content><![CDATA[<p>黑神话最开始看到的一些评测是让我对其 ARGP 中的 A 抱有比较大期望值的，但实际上手后的2小时其实是比较失望的。但后面升级后也算有一些改善，不过也不太能去期待他战斗动作能够有非常好的体验了。</p>
<span id="more"></span>

<h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><ul>
<li>空气墙<br>最大问题是没有统一的设计让你能够辨别这里是否有空气墙，包括一些跳跃可以上去的地方。</li>
<li>迷路<br>起初都还好，只是探索欲比较旺盛的人可能会花很多时间，后面小西天雪山是地图又大，人物跑起来又慢，周围景色我是真不能辨别，我期间是逐渐失去耐心的。 </li>
</ul>
<h2 id="人物性能"><a href="#人物性能" class="headerlink" title="人物性能"></a>人物性能</h2><p>韧性非常差，一些小攻击造成吃一套，你也同样不好立刻反击，比如A，通常都是狂按闪避了。</p>
<p>喝药非常慢，加上一些boss的一套combo，你很多时候是有药也没空喝。</p>
<h2 id="妖怪技（精魄）"><a href="#妖怪技（精魄）" class="headerlink" title="妖怪技（精魄）"></a>妖怪技（精魄）</h2><ul>
<li>使用的时候会受伤</li>
<li>幽魂打断非常好，但是很容易空</li>
</ul>
<h2 id="闪避"><a href="#闪避" class="headerlink" title="闪避"></a>闪避</h2><ul>
<li>完美闪避判定非常苛刻</li>
<li>多段攻击完美闪避体验非常糟糕，很多时候不如大闪出攻击范围</li>
<li>闪避只有第一段手感还好，后面非常粘手的感觉，有时候很难分辨到底闪到没有，加上初期轻攻击1段突进不够距离，闪出去基本就开始下个回合了</li>
<li>完美闪避后没有什么很好的回报</li>
</ul>
<h2 id="GP"><a href="#GP" class="headerlink" title="GP"></a>GP</h2><p>劈棍的GP</p>
<ul>
<li>要求棍势，2段貌似也要求</li>
<li>会受伤，或者你可以完美闪避前面招式看最后一下，因为GP到的那一下是无伤的</li>
<li>2段很容易空</li>
<li>并不太能打断敌方招式，或者说能够打断的招式并不多</li>
<li>GP的节点并不那么自由，一般都要A一下稍微等等看boss攻击，用枪要简单一些，可以A完立即GP，另外3段的花棍会被打断导致GP手感很不好。</li>
<li>貌似并不能GP那种高伤技能，2段我也被高伤技能打断过</li>
<li>没GP到他是会后撤一点的，很容易GP拿一下也打不中</li>
<li>综上，高风险低收益</li>
</ul>
<h2 id="Boss战"><a href="#Boss战" class="headerlink" title="Boss战"></a>Boss战</h2><p>boss有那种虽然有明显前摇动作，但是攻击瞬间非常快，加上完美闪避判断苛刻，没有好回报，导致回合制体验非常严重，你不太想在boss回合内反制他。 </p>
<p>有时候镜头很难判断boss出招的一个全貌，或者说你看不见boss的动作。</p>
<p>你的回合内如果突入boss攻击（其实就是你的回合时间太短还没放完招），你可以：</p>
<ul>
<li>化身幽魂高打断（其实也是建议这样，因为经常空放boss到处跑会空），其他的暂时不知道好不好用在这个时候，但你会受伤</li>
<li>身法中散气可以做到后撤闪避的效果，打断也看起来还行</li>
<li>GP，通常没法GP，GP吃一套伤害非常感人的，除非算计好boss攻击的时候或者那种看起来非常简单的你可以GP，但闪完再GP是可以考虑的</li>
<li>也许你已经进入最后一段轻攻击，直接打下去造成打断，打断效果好像挺一般，这一下有一些韧性（但不多）</li>
</ul>
<p>综上，你一般就是赶紧躲开等下个回合，因为上面有很多都有不短的冷却，而且还有些消耗法力值。或者也可以稍微周旋等冷却进行一套法术的长输出/与boss攻击中交互。</p>
<p>比较通解的是蓄力上去开局，蓄力换血，隐身蓄力，然后就是那些比较轮椅的套装了。有种你不太去找法术，安排使用法术或者搭配套装，你的难度曲线是会突然增高很多的，而一些好用的法术套路看起来跟boss交互性都比较差。</p>
<p>因为道中一些小怪有时候都是开挂无限喝药打死的，很多时候看起来都找不太到解法，基本就是跳过了，所以没什么特别记录。其他的有印象的，卡的比较久的就记录一下。</p>
<h3 id="幽魂"><a href="#幽魂" class="headerlink" title="幽魂"></a>幽魂</h3><p>场地受到空气墙影响非常大，因为boss基本招式判定范围非常大，你会很想闪出一个大范围，然后就很容易碰到空气墙</p>
<h3 id="虎先锋"><a href="#虎先锋" class="headerlink" title="虎先锋"></a>虎先锋</h3><p>GP起来比较难而且吃后面几个连段的伤害，不是那么赚，最简单的还是回合制，躲过就打打，一般他打完会往回撤。 </p>
<p>快慢刀可以有那种不好预测的长滞空下落攻击，几乎是背板，典型的那几拳跟刀的前两次砍看似还没开始打到你，但其实你就该闪了，而且这是完美闪避的时机，而且还是那种中间就间隔一小会的连闪，手感跟看到的感觉是不一样的。</p>
<p>一些长滞空的快慢刀经常安插在攻击间隔中，镜头机位低，很容易造成上面提到的boss动作根本看不清（看不见）。</p>
<p>中后期有那种化成石头后隐身一冲的技能，我不知道能不能打到隐身的它，打不到就是干站着准备躲技能了。</p>
<blockquote>
<p>PS: 他镜头是真的有问题，有些时候你可以试试定身，机位直接让你仰望他，视角特别难受。</p>
</blockquote>
<h3 id="黄风大圣"><a href="#黄风大圣" class="headerlink" title="黄风大圣"></a>黄风大圣</h3><p>久仰大名的0帧起手投技，感觉上应该是起手动作的，起码我看到腿是在动的，但是很多动作腿都在动，我说实话通关了都没辨别出来，所以体感几乎是0帧起手，抓需范围很大。</p>
<p>起手基本就是蓄力+身外身法+AA途中看到攻击就定身+一套轻攻击+蓄力。<br>后面稍微躲躲技能就好了，实际上技能还是很好躲的，不像是虎先锋不能够预测，基本是背板的，但是最后的龙卷风要注意一下，我可能幸运特别快就过了。  </p>
<p>总体而言卡的比虎先锋短很多时间，也许技能上来了，前期一顿胖揍确实也大了很多血。<br>但听说这里boss容易跳出空气墙外面导致你摸不到他，我因为一套下来用不了多久就开始转阶段，还没有感受到。</p>
<h3 id="亢金龙"><a href="#亢金龙" class="headerlink" title="亢金龙"></a>亢金龙</h3><p>镜头问题更加严重，而且经常帮你锁头，导致有时候都打不到尾巴。</p>
<p>基本就是看boss表演，你只要躲完跑过去蹭血就好了，因为我换了戳棍打，经常打不到它，感觉要立辊。</p>
<p>另外它投技虽然还好躲，但是依然是从很远的地方一下子突进过来，基本也不太能预测，要提前。</p>
<h3 id="魔将·妙音"><a href="#魔将·妙音" class="headerlink" title="魔将·妙音"></a>魔将·妙音</h3><p>更加糟糕的镜头问题，更加糟糕的锁定问题。打起来更多的也是看演出，交互还是少，我最开始都是蒙头一直修脚。</p>
<p>自己打后面打的没伤害，卡了很久就跑去看攻略了，基本就是打带红的脚（右前）让他倒下然后打头，平时有机会也可以摸到头，但是锁定很糟糕。</p>
<p>另外依然是看不懂的投技。</p>
<h3 id="亢金星君"><a href="#亢金星君" class="headerlink" title="亢金星君"></a>亢金星君</h3><p>卡了我特别久，技能非常不好躲，伤害还不低，特别是二阶段我甚至不知道什么时候输出好，每次碰两下就要被打，GP点我基本摸不到（指不定某些还是不让你GP的），蓄力还会被远程追击，这boss是不是必须上对策难度才没这么变态啊。</p>
<p>最后没办法只能够查攻略逃课了：喝酒上buff，开局三蓄，隐身再三蓄，AA开定身（或者看到开始攻击）再轻攻击一套，反正打到boss上天开石头人躲伤害，期间第一次满了释放特殊技，第二次满了等下来再打，化身解开后立即隐身三蓄，然后再打打开定身，然后随便打一下让boss上天，开定风珠再打基本就死了。</p>
<h3 id="黄眉"><a href="#黄眉" class="headerlink" title="黄眉"></a>黄眉</h3><p>不知道应该算简单还是怎么样，打起来算是舒服的。</p>
<h3 id="百眼魔君"><a href="#百眼魔君" class="headerlink" title="百眼魔君"></a>百眼魔君</h3><p>血压拉满ww，正面碰撞模型比实际看到的boss模型大一些导致你会被卡住，然后攻击判定的模型或者说大小却并不像碰撞模型那么大，你正面平A就是会被挡住根本没伤害，导致很多技能都会空，侧面虽然能摸到脚但是仍然是攻击判定很糟糕，很多时候都会空，加上人物本身锁定+技能招式追踪问题，你真的会觉得非常搞笑了。</p>
<p>后面虽然能打进3阶段但是缺少道具几乎被秒杀，就回头去找道具了，但是拿道具需要先去打毒敌大王再去打拿道具的boss，于是乎就跑去打毒敌大王了。</p>
<h3 id="毒敌大王"><a href="#毒敌大王" class="headerlink" title="毒敌大王"></a>毒敌大王</h3><p>你几乎必须掌握操控人物的闪避性能或者说要求你就应该要完美闪避（熟悉boss），不然你就是一直挨揍。</p>
<p>毒敌大一套体操并不长，但是间隔并不短，或者说每套每套互相之间要打个好几套才有间隔，而且范围及其广，突进对人物来说也是非常远的，加上人物闪避性能，你很难有休息的时间，或者说你不能能够一直闪出去休息，更多的是看boss行动，找到空隙补血，不然就要集中精力一直闪避。  </p>
<p>也许是我太过自信都没有加过血量，加上boss伤害不俗，一套体操你应该人就没了，特别是你有时候甚至没有掌握准时机想要用一些长演出的技能时，应该能吃上半管血，boss的韧性也是游离不定的，有时候时非常好打断的有时候就很强，大多感觉是某种保护机制生效了不让你一直连。</p>
<p>Anyway，我打到这里的时候已经逐渐对游戏失去兴趣了，原本还想正面不逃课不太依靠法术赖皮打法过boss，现在玩起来只有折磨，爽快度一直是找不太到的，故几乎打算在这里封盘了。</p>
<h2 id="总体感想"><a href="#总体感想" class="headerlink" title="总体感想"></a>总体感想</h2><p>28小时，盘丝洞百眼魔君，GP没怎么练，目前也就试过带不能做简单aaa连招，通常都是赖皮一套法术打进残血（aaa看boss动作定身，aaa不能，看情况能不能打进4段棍势，劈棍重击，随便打打开隐身蓄力）。  </p>
<p>战斗体操作验来说我觉得看似像只狼，但实际打起来更像是魂系稍微加强点动作。尽管技能多，但我几乎还是一直在平A。然后我回头去看了一下只狼，战斗体验来说由于经常性的格挡弹刀，攻守交换也非常频繁（拉长了应该也比较像黑猴回合制了），期间由于人物性能其实可以穿插一些有趣的道具（冷却以及资源数量都还可以），平A等等，整体是非常平滑的，加上boss的设计，我不太会在意只狼AAA的贫乏，实际上我应该都是专注于跟boss的交互，AAA都是半自动的见缝插针。黑猴整体有很多boss爆发回，长演出，特别是神经刀让你整体体验都没有那么爽快，有时候甚至觉得是比较折磨的，而且AAA你其实不能够半自动，还有预输入问题导致你的精力不单只是集中在跟boss周旋，还要在意你的出招问题，特别还有一些幽默的长演出技能吃boss伤害的问题。<br>在诸多问题的加持下我觉得黑猴战斗更多时候对我来说是折磨，我除了虎先锋认真对待应对每个技能外，其他大多都是追求着0交互的战斗。</p>
<p>美术应该是黑猴最大的优点了，还有良好的配音（毕竟看起来就单纯是非动画片的配音，应该是那些演员熟悉的领域），然后就是丰富的敌人跟boss，除此之外大多都让我感到印象差。  </p>
<p>boss设计的那种神经刀让我感到没意思，特别是一些拳脚招式大多让我感到无法理喻，虎先锋跟不能的扫堂腿看似极其无力其实是极具伤害的，一些招式应该需要更高的速度感他以缓慢的速度滞空出招，你也很多时候不觉得这个招式应该以这样的速度进行（预测招式的动作），这其中也带有没有速度感动作也没有力量感导致的奇怪动作打击伤害让人摸不着头脑。<br>与之相对，有一些技能是攻击判定时动作极其迅速你需要背板，就比如一些看似前摇蓄力慢，实则正真你能通过动作判定的帧数应该很少，所以需要靠背板。</p>
<p>故事来说我没有去认真看，毕竟对原著也不熟悉。播片的动画以美术来说还是很有意思的，以故事来说就挺一般，甚至小西天章节结尾动画最后那个时金蝉子吗？整一个活脱脱非那个时代的帅哥。</p>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>黑神话</tag>
        <tag>Black Myth</tag>
        <tag>Gameplay</tag>
      </tags>
  </entry>
  <entry>
    <title>用Gradle构建lib分离的jar包</title>
    <url>/2022/06/23/build-thin-jar-with-external-lib-by-gradle/</url>
    <content><![CDATA[<p>如果平时比较多使用docker部署，那么为了节省部署的时间，一般会把一些不太变化的东西放在比较前面写作为一层，分层处理后可以利用编译的缓存快速构建出镜像。</p>
<p>因此，如果一个jar包是分离lib的话就可以做灵活的分层处理了。</p>
<span id="more"></span>
<blockquote>
<p>封面：Shadowverse 5周年贺图，角色是<del>我女儿</del>雪华。BTW，这个角色的cv是刚出道的时候非常呆萌非常贪吃的<a href="https://www.bilibili.com/video/BV194411M7mt">もちょ</a>。</p>
</blockquote>
<hr>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>最近由于接触了一下Quarkus，发现其打包jar的方式非常棒，分离了lib，最终推送docker镜像时利用缓存只需要1M不到的数据量，虽然我以前是知道maven有类似的插件的，但是由于最近我完全入坑gradle了，也尝试过找类似的插件但都未果，此次因为尝到了甜头，以及我不想要绑定quarkus框架所以又去找了一下解决方案。</p>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>首先Jar包内是有一个<code>META-INF/MANIFEST.MF</code>这样的文件，里面我只挑能够达成jar包跟lib分离目的的参数：</p>
<ul>
<li>Main-Class<br>  这是指定程序入口的参数，一般就是main方法所在的class，Kotlin的class需要加上Kt的后缀才正确。<br>  这个一般打成jar运行是基础配置，不然无法运行。</li>
<li>Class-Path<br>  这个就是需要加载的lib的配置了，需要对每个lib包都做声明，空格分割。</li>
</ul>
<p>下一步是对Gradle的jar任务做修改，让其排除所有的*.jar文件，并自定义一个删除以及拷贝lib的任务让其依赖。这需要了解一下Gradle如何自定义一个task以及jar任务如何修改。</p>
<h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>了解完上面说的两点，就可以直接上代码了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">tasks.register&lt;Delete&gt;(<span class="hljs-string">&quot;clearLib&quot;</span>) &#123; <span class="hljs-comment">//清除lib</span><br>    delete(<span class="hljs-string">&quot;<span class="hljs-variable">$buildDir</span>/libs/lib&quot;</span>)<br>&#125;<br><br>tasks.register&lt;Copy&gt;(<span class="hljs-string">&quot;copyLib&quot;</span>) &#123; <span class="hljs-comment">//拷贝lib</span><br>    from(configurations.runtimeClasspath) <span class="hljs-comment">//从运行时目录</span><br>    into(<span class="hljs-string">&quot;<span class="hljs-variable">$buildDir</span>/libs/lib&quot;</span>)  <span class="hljs-comment">//到打包目录</span><br>&#125;<br><br>tasks.jar &#123;<br>    dependsOn(<span class="hljs-string">&quot;clearLib&quot;</span>) <span class="hljs-comment">//依赖清除和拷贝lib任务</span><br>    dependsOn(<span class="hljs-string">&quot;copyLib&quot;</span>)<br>    exclude(<span class="hljs-string">&quot;**/*.jar&quot;</span>) <span class="hljs-comment">//打包时排除jar文件（不打包成fat jar）</span><br>    manifest &#123;<br>        attributes[<span class="hljs-string">&quot;Manifest-Version&quot;</span>] = <span class="hljs-string">&quot;1.0&quot;</span><br>        attributes[<span class="hljs-string">&quot;Multi-Release&quot;</span>] = <span class="hljs-string">&quot;true&quot;</span><br>        attributes[<span class="hljs-string">&quot;Main-Class&quot;</span>] = <span class="hljs-string">&quot;moe.kurenai.bot.BgmApplicationKt&quot;</span> <span class="hljs-comment">//main方法所在的class，我这个例子是用的Kotlin所以带有Kt后缀</span><br>        attributes[<span class="hljs-string">&quot;Class-Path&quot;</span>] = configurations.runtimeClasspath.<span class="hljs-keyword">get</span>().files.map &#123; <span class="hljs-string">&quot;lib/<span class="hljs-subst">$&#123;it.name&#125;</span>&quot;</span> &#125;.joinToString(<span class="hljs-string">&quot; &quot;</span>)  <span class="hljs-comment">//构建出 lib/包名 的字符串并用空格分隔</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Manifest-Version: 1.0<br>Multi-Release: <span class="hljs-literal">true</span><br>Main-Class: moe.kurenai.bot.BgmApplicationKt<br>Class-Path: lib/bangumi-sdk-0.0.1-SNAPSHOT.jar lib/td-light-sdk-0.0.1-SN<br> APSHOT.jar lib/kotlinx-coroutines-core-jvm-1.6.1.jar lib/kotlin-stdlib-<br> jdk8-1.6.21.jar lib/simple-cache-1.2.0-SNAPSHOT.jar lib/redisson-3.17.1<br> .jar lib/reflections-0.10.2.jar lib/log4j-core-2.17.1.jar lib/log4j-api<br> -2.17.1.jar lib/disruptor-3.4.4.jar lib/jackson-module-kotlin-2.13.1.ja<br> r lib/jackson-dataformat-yaml-2.13.1.jar lib/kotlin-stdlib-jdk7-1.6.21.<br> jar lib/kotlin-reflect-1.6.21.jar lib/kotlin-stdlib-1.6.21.jar lib/jack<br> son-datatype-jdk8-2.13.1.jar lib/jackson-datatype-jsr310-2.13.1.jar lib<br> /jackson-databind-2.13.1.jar lib/lettuce-core-6.1.6.RELEASE.jar lib/rea<br> ctor-core-3.4.17.jar lib/jackson-core-2.13.1.jar lib/jackson-annotation<br> s-2.13.1.jar lib/commons-lang3-3.12.0.jar lib/commons-pool2-2.10.0.jar <br> lib/commons-codec-1.3.jar lib/kryo-5.3.0.jar lib/netty-resolver-dns-4.1<br> .74.Final.jar lib/netty-handler-4.1.74.Final.jar lib/netty-codec-dns-4.<br> 1.74.Final.jar lib/netty-codec-4.1.74.Final.jar lib/netty-transport-4.1<br> .74.Final.jar lib/netty-buffer-4.1.74.Final.jar lib/netty-resolver-4.1.<br> 74.Final.jar lib/netty-common-4.1.74.Final.jar lib/cache-api-1.1.1.jar <br> lib/rxjava-3.0.12.jar lib/reactive-streams-1.0.3.jar lib/jboss-marshall<br> ing-river-2.0.11.Final.jar lib/jboss-marshalling-2.0.11.Final.jar lib/s<br> lf4j-api-1.7.36.jar lib/byte-buddy-1.11.0.jar lib/jodd-bean-5.1.6.jar l<br> ib/javassist-3.28.0-GA.jar lib/jsr305-3.0.2.jar lib/kotlin-stdlib-commo<br> n-1.6.21.jar lib/annotations-13.0.jar lib/reflectasm-1.11.9.jar lib/obj<br> enesis-3.2.jar lib/minlog-1.3.1.jar lib/snakeyaml-1.28.jar lib/netty-tc<br> native-classes-2.0.48.Final.jar lib/jodd-core-5.1.6.jar<br></code></pre></td></tr></table></figure>

<h2 id="0x03-1"><a href="#0x03-1" class="headerlink" title="0x03"></a>0x03</h2><p>上面只是比较简单的示例，你还可以对你不经常变动的包分到另一个目录当中去（例如<code>bangumi-sdk-0.0.1-SNAPSHOT.jar</code>这个包是我自己写的sdk，会经常变动），这样更加能够利用好缓存构建docker镜像，实际上quarkus是分了4个文件夹。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Kotlin</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor中的上下文</title>
    <url>/2020/09/08/context-of-reactor/</url>
    <content><![CDATA[<p>由于参与的项目当中决定用 <a href="https://github.com/spring-cloud/spring-cloud-gateway">spring-cloud-gateway</a> 作为网关，所以自然就碰上了Reactor当中获取上下文的问题。    </p>
<p>这里我是遇到了 I18N 需要获取上下文中 Locale 的问题，所以我就以这个问题举例，提供其中一种上下文的解决方法。  </p>
<span id="more"></span>

<h2 id="What-happened"><a href="#What-happened" class="headerlink" title="What happened"></a>What happened</h2><p>在使用 I18N 进行国际化时，Servlet 框架下我们通常会使用 ThreadLocal 进行储存解析请求得到上下文的 Locale 对象，以判断当前请求需要的是什么语言。<br>但在 Reactor 框架下，由于一个请求整个流程下来，线程都在不断的进行切换，所以 ThreadLocal 自然也就失去上下文储存对象的能力。</p>
<p>经过简单的谷歌查询，我只能想两种处理方法：  </p>
<ol>
<li>从 controller 获取 Locale 或者任意能够得到 Exchange（类似 Request）的方法开始一路传递下去。</li>
<li>直接将 I18N 的 key 传入自定义异常对象当中，然后在统一异常处理类当中获取 Exchange 再做进一步的国际化操作。</li>
</ol>
<p>但他们都不够优雅，而且其中弊端也很明显，一个是需要无限传递变量，一个是只能限制再异常处理类进行处理，理所当然就无法添加国际化的变量。</p>
<h2 id="How-should-I-do"><a href="#How-should-I-do" class="headerlink" title="How should I do"></a>How should I do</h2><h3 id="如何取值"><a href="#如何取值" class="headerlink" title="如何取值"></a>如何取值</h3><p>令人喜悦的是，Spring 其实已经写了一个获取上下文的例子了，它就是<code>ReactiveSecurityContextHolder</code>，对应 Servlet 当中的<code>SecurityContextHolder</code>。</p>
<p>ReactiveSecurityContextHolder#getContext</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Class</span>&lt;?&gt; <span class="hljs-type">SECURITY_CONTEXT_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-type">SecurityContext</span>.class;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Mono</span>&lt;<span class="hljs-type">SecurityContext</span>&gt; getContext() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Mono</span>.subscriberContext()<br>            .filter( c -&gt; c.hasKey(<span class="hljs-type">SECURITY_CONTEXT_KEY</span>))       <br>            .flatMap( c-&gt; c<span class="hljs-operator">.&lt;</span><span class="hljs-type">Mono</span>&lt;<span class="hljs-type">SecurityContext</span>&gt;<span class="hljs-operator">&gt;</span><span class="hljs-keyword">get</span>(<span class="hljs-type">SECURITY_CONTEXT_KEY</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，通过<code>Mono.subscriberContext()</code>，我们可以得到一个上下文对象，然后他先判断是否包含给出的key值，包含则获取值。<br>这里需要注意，如果直接获取值会抛出异常。   </p>
<h3 id="如何赋值"><a href="#如何赋值" class="headerlink" title="如何赋值"></a>如何赋值</h3><p>当我查看<code>withSecurityContext</code>方法时，其注释告诉我是用来创建一个包含<code>SecurityContext</code>的 Reactor 上下文对象（Context）并可被用于与其他上下文对象（Context）进行合并。  </p>
<p>所以当我们查看有什么方法调用它时，就会发现<code>ReactorContextWebFilter</code>这个过滤器。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactorContextWebFilter</span> <span class="hljs-title">implements</span> <span class="hljs-title">WebFilter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSecurityContextRepository repository;<br><br>    <span class="hljs-keyword">public</span> ReactorContextWebFilter(ServerSecurityContextRepository repository) &#123;<br>        Assert.notNull(repository, <span class="hljs-string">&quot;repository cannot be null&quot;</span>);<br>        <span class="hljs-keyword">this</span>.repository = repository;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;<span class="hljs-built_in">Void</span>&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123;<br>        <span class="hljs-keyword">return</span> chain.filter(exchange)<br>            .subscriberContext(c -&gt; c.hasKey(SecurityContext.<span class="hljs-keyword">class</span>) ? c :<br>                withSecurityContext(c, exchange)<br>            );<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Context withSecurityContext(Context mainContext, ServerWebExchange exchange) &#123;<br>        <span class="hljs-keyword">return</span> mainContext.putAll(<span class="hljs-keyword">this</span>.repository.load(exchange)<br>            .<span class="hljs-keyword">as</span>(ReactiveSecurityContextHolder::withSecurityContext));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>ServerSecurityContextRepository#load</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> Mono&lt;SecurityContext&gt; load(ServerWebExchange exchange) &#123;<br>    <span class="hljs-keyword">return</span> exchange.getSession()<br>        .map(WebSession::getAttributes)<br>        .flatMap( attrs -&gt; &#123;<br>            SecurityContext context = (SecurityContext) attrs.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">this</span>.springSecurityContextAttrName);<br>            <span class="hljs-keyword">return</span> Mono.justOrEmpty(context);<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>ReactiveSecurityContextHolder#withSecurityContext</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function">Context <span class="hljs-title">withSecurityContext</span><span class="hljs-params">(Mono&lt;? <span class="hljs-keyword">extends</span> SecurityContext&gt; securityContext)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> Context.<span class="hljs-title">of</span><span class="hljs-params">(SECURITY_CONTEXT_KEY, securityContext)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过阅读上面的代码可得知，上面的过滤器通过<code>ServerSecurityContextRepository</code>解析请求中的 Security 上下文，通过<code>ReactiveSecurityContextHolder</code>生成 Securtiy 上下文对象并返回。</p>
<h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h2><p>我们可以仿照着写一个从请求对象当中解析出一个 Locale 对象并放入上下文当中（不确定是不是上下文，但是Reactor确实是用这种办法实现了上下文的功能）。  </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 将 Locale 放到上下文中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactorLocaleContextWebFilter</span> <span class="hljs-title">implements</span> <span class="hljs-title">WebFilter</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;<span class="hljs-built_in">Void</span>&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123;<br>        <span class="hljs-keyword">return</span> chain.filter(exchange)<br>            .subscriberContext(c -&gt; c.hasKey(Locale.<span class="hljs-keyword">class</span>) ? c :<br>                withLocaleContext(c, exchange)<br>            );<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Context withLocaleContext(Context mainContext, ServerWebExchange exchange) &#123;<br>        <span class="hljs-comment">//解析请求获取 Locale </span><br>        Locale locale = getLocale(exchcange);<br>        <span class="hljs-keyword">return</span> mainContext.putAll(Context.of(Locale.<span class="hljs-keyword">class</span>, Mono.justOrEmpty(locale)));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//获取 Locale</span><br>Mono.subscriberContext()<br>            .filter( c -&gt; c.hasKey(Locale.<span class="hljs-keyword">class</span>))       <br>            .flatMap( c-&gt; c.&lt;Mono&lt;Locale&gt;&gt;<span class="hljs-keyword">get</span>(Locale.<span class="hljs-keyword">class</span>));<br></code></pre></td></tr></table></figure>


<p>具体实现我日后会写一个demo。<del>咕咕咕</del></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Reactor</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reactor</tag>
        <tag>Webflux</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>GraalVM With Spring</title>
    <url>/2023/07/12/graalvm-with-spring-boot/</url>
    <content><![CDATA[<p>最初看见 GraalVM 的时候我就想到 <strong>Make jvm great again!</strong> ！！<br>实际上我也在之前尝试过几次，但都是不理想或者失败了。这次我看到 Spring Boot 3 对 GraalVM 的支持更加完善了，就又想跑过来试试了，毕竟写 Kotlin 编译成 Native 还是太香了！（<del>Kotlin 香，Native 香，香两次，简直香麻了</del>）<br>同样这次也都还是做一些折腾的记录。</p>
<span id="more"></span>
<blockquote>
<p>封面：画师是<del>我岳父</del><a href="https://www.pixiv.net/users/3952">おにねこ</a>，<a href="https://www.pixiv.net/artworks/103834884">封面链接</a>。<br>就说这位画师非常适合黑色哥特萝莉，201x年初时其实脸跟一些细节都让人感觉比较潦草，但是非常个人风格，背景也很好。现在整体都相较要好很多，细节要更加多。</p>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GraalVM 与传统在 JVM 中运行的 JIT 编译不同，他是 AOT 编译。由于去掉了 JVM 后一些运行时的动态分析就会失效，如反射，代理，JNI，SPI 等等，而这里面一些资源也要显式声明，所以你需要大量的去告诉编译器这个类实际上运行时是谁，让它去分析这个类、资源的信息，最后才能够在运行时找到。</p>
<p>这几乎就是转 GraalVM 的全部工作了，但不得不说这些工作量还是很大的。最初时大多项目都没有提供支持，导致你需要自己等待编译，然后运行报错看提示再去告诉编译器需要分析什么东西。</p>
<p>如今，大多常用的包都有给出一些反射、代理或者资源的配置了，所以我又准备尝试了。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows 环境非常恶劣，起初我几乎放弃了。<br>就算是现在我也不能说我真的就了解怎么搭建环境了。<br><del>所以珍惜生命远离 Windows</del></p>
<p>Ok，其实现在 GraalVM 的官网上面已经放出了一篇<a href="https://medium.com/graalvm/using-graalvm-and-native-image-on-windows-10-9954dc071311">教程</a>，只需要安装好 vs 当中的一些组件即可</p>
<p><strong>重点</strong>：找到<code>x64 Native Tools Command Prompt for VS 2022</code>这个快捷方式，打开进入cmd，可以看到有个x64的输出，这个环境就算准备好了，2022可以是别的，但是前缀应该就是这些，x86是不支持的，交叉编译不知道。</p>
<p>最后配置一下环境变量 <code>GRAALVM_HOME</code> 跟 <code>JAVA_HOME</code> 就好了了，这是为了 gradle 的 graalvm 的插件（<code>org.graalvm.buildtools.native</code>）做准备。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他大概就不太需要说明了，只要装上 GraalVM 的 sdk 就行了。</p>
<h2 id="GraalVM-配置"><a href="#GraalVM-配置" class="headerlink" title="GraalVM 配置"></a>GraalVM 配置</h2><p>GraalVM 的配置是放在 <code>resource/META-INF/native-image/</code> 下面，我不太记得非 spring 项目下是不是默认读取这个目录下的配置了，这块现在<a href="https://github.com/oracle/graalvm-reachability-metadata">这个</a>仓库有维护一些配置，可以直接拿过来用，主要是 copy 里面的 <code>reflect-config.json</code>, <code>proxy-config.json</code>，<code>jni-config.json</code>，<code>resource-config.json</code></p>
<h2 id="Spring-配置"><a href="#Spring-配置" class="headerlink" title="Spring 配置"></a>Spring 配置</h2><p>依赖什么的这个也没有什么特别说的，直接在<a href="https://start.spring.io/">start.spring.io</a>上面选好依赖，查看它配置文件怎么写就好了。</p>
<h2 id="RuntimeHintsRegistrar"><a href="#RuntimeHintsRegistrar" class="headerlink" title="RuntimeHintsRegistrar"></a>RuntimeHintsRegistrar</h2><p>因为自己手写 json 不太可能的（<del>手写是不可能手写的，这辈子都不可能</del>），毕竟太多了不是人干的活，所以 GraalVM 有一个 agent 可以分析一下运行时情况。但是也不一定能够分析全，例如运行时并没有跑某几段代码等，所以我们就需要<code>RuntimeHintsRegistrar</code>来代码生成。</p>
<p>这个类貌似GraalVM也有提供，但是因为用的 Spring，GraalVM 提供的就没有去研究了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// hints 和 classLoader 都是实现这个类的`registerHints`方法传入的参数</span><br><br><span class="hljs-comment">// 私有类无法访问时</span><br>hints.reflection().registerTypeIfPresent(classLoader, <span class="hljs-string">&quot;com.github.benmanes.caffeine.cache.PSWMW&quot;</span>, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)<br><br><span class="hljs-comment">// 一般情况，后面的 MemberCategory 类型就是要注册的东西，可以是全部方法、字段或者是 public 的方法、字段等等</span><br>hints.reflection().registerType(ConstructorDetector::<span class="hljs-keyword">class</span>.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_METHODS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_CLASSES)<br><br><span class="hljs-comment">// 拥有内部类的时候</span><br>AtomicLongFieldUpdater::<span class="hljs-keyword">class</span>.java.declaredClasses.forEach &#123;<br>    hints.reflection().registerTypeIfPresent(classLoader, it.name, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_METHODS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_CLASSES)<br>&#125;<br><span class="hljs-comment">// 一些基础类型的注册</span><br>hints.jni().registerType(java.lang.<span class="hljs-built_in">Boolean</span>::<span class="hljs-keyword">class</span>.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br>hints.jni().registerType(java.lang.Integer::<span class="hljs-keyword">class</span>.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br>hints.jni().registerType(java.lang.<span class="hljs-built_in">Long</span>::<span class="hljs-keyword">class</span>.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br>hints.jni().registerType(java.lang.<span class="hljs-built_in">Double</span>::<span class="hljs-keyword">class</span>.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br>hints.jni().registerType(java.lang.String::<span class="hljs-keyword">class</span>.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br>hints.jni().registerType(java.util.Arrays::<span class="hljs-keyword">class</span>.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br>hints.jni().registerType(Array::<span class="hljs-keyword">class</span>.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br>hints.jni().registerType(IntArray::<span class="hljs-keyword">class</span>.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br>hints.jni().registerType(LongArray::<span class="hljs-keyword">class</span>.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br>hints.jni().registerType(DoubleArray::<span class="hljs-keyword">class</span>.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br>hints.jni().registerType(BooleanArray::<span class="hljs-keyword">class</span>.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br><br><span class="hljs-comment">// jni内部类的注册</span><br>TdApi::<span class="hljs-keyword">class</span>.nestedClasses.forEach &#123; clazz -&gt;<br>    <span class="hljs-keyword">if</span> (clazz.isSubclassOf(TdApi.Function::<span class="hljs-keyword">class</span>).not()) &#123;<br>        hints.jni().registerTypeIfPresent(classLoader, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;clazz.name&#125;</span>[]&quot;</span>)<br>    &#125;<br><span class="hljs-comment">//            clazz.java.declaredMethods.forEach &#123;</span><br><span class="hljs-comment">//                hints.jni().registerMethod(it, ExecutableMode.INVOKE)</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//            clazz.java.fields.forEach &#123;</span><br><span class="hljs-comment">//                hints.jni().registerField(it)</span><br><span class="hljs-comment">//            &#125;</span><br>    hints.reflection().registerType(clazz.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br>    hints.jni().registerType(clazz.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)<br>&#125;<br><br><span class="hljs-comment">// 资源的注册</span><br>hints.resources().registerPattern(<span class="hljs-string">&quot;META-INF/tdlightjni/*&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>写完这个类后，找个<code>@Configuration</code>的类或者程序入口类添加<code>@ImportRuntimeHints(YourHintsRegirar::class)</code>，这样他就会编译的时候在<code>build/generated/aotResources</code>下生成对应的配置文件，可以打开检查一下生成有没有问题。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>Ok，万事俱备了，就剩下编译了。</p>
<blockquote>
<p>Windows编译必须要在刚刚说到的<code>x64 Native Tools Command Prompt for VS 2022</code>当中执行命令。</p>
</blockquote>
<p>执行<code>gradle nativeCompile</code>等待编译完成。</p>
<p>编译完成会在<code>build/native/nativeCompile</code>目录下找到可执行文件，执行即可。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这东西我 5600X 几乎需要花 3min+ 编译，当你不太确定或者一些库用了大量反射或者大量个人库但是没有相关配置的时候，你可能需要给他写大量的配置文件，重复 N 次编译，所以如果可以，还是在配置比较高的情况下玩，不然一天很快过去的www</p>
]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>GraalVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/03/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<!--more-->
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题笔记01</title>
    <url>/2021/05/17/interview-note-01/</url>
    <content><![CDATA[<p>记录一下看过的一些面试题。</p>
<span id="more"></span>
<blockquote>
<p>封面<br>这位画师的脸以及上色很有特点，稍微留意一下很容易就能够辨别出来了，只是表情总给人一种同样的感觉w<br><a href="https://twitter.com/__LM7__/status/1379416474293465090">https://twitter.com/__LM7__/status/1379416474293465090</a></p>
</blockquote>
<h2 id="MQ接收到消息后无法查询到或者是旧的状态"><a href="#MQ接收到消息后无法查询到或者是旧的状态" class="headerlink" title="MQ接收到消息后无法查询到或者是旧的状态"></a>MQ接收到消息后无法查询到或者是旧的状态</h2><p>原因</p>
<ul>
<li>数据库回滚  </li>
<li>数据库事务未提交</li>
</ul>
<p>解决办法</p>
<ul>
<li>可以尝试将mq放在数据库事务之后执行。</li>
<li>可以利用@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)监听spring事务afterCommit阶段。  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">saveFoo</span><span class="hljs-params">(FooEntity fooEntity)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    log.error(<span class="hljs-string">&quot;start insert foo&quot;</span>);<br>    fooRepository.save(fooEntity);<br>    publisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTransactionEvent</span>(fooEntity.getFooName()));<br>    log.error(<span class="hljs-string">&quot;end insert foo&quot;</span>);<br>    Thread.currentThread().sleep(<span class="hljs-number">2000</span>);<br>    log.error(<span class="hljs-string">&quot;to commit insert&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">(MyTransactionEvent event)</span> &#123;<br>    log.error(<span class="hljs-string">&quot;after commit then send event &#123;&#125;&quot;</span>, event);<br>    log.error(<span class="hljs-string">&quot;after commit then send event &#123;&#125;&quot;</span>, event.getName());<br>&#125;<br></code></pre></td></tr></table></figure>
  发送的spring事件会在监听到AFTER_COMMIT时执行<br>  参考：<a href="https://blog.csdn.net/little_kelvin/article/details/111330768">https://blog.csdn.net/little_kelvin/article/details/111330768</a></li>
</ul>
<h2 id="MQ偶然接收到重复消息"><a href="#MQ偶然接收到重复消息" class="headerlink" title="MQ偶然接收到重复消息"></a>MQ偶然接收到重复消息</h2><p>接收端消费了消息但是没有向broker发送ack或者broker没有接收到ack，导致broker将消息再次入队被其他接收端或同一个接收端消费，造成了重复消费消息</p>
<p>接收端方法做幂等：<br>新增，则可以在消息做一个唯一主键，重复了则会异常，保证数据库没有脏数据。<br>修改，一般都为幂等，修改多少次一般都是一样的结果。</p>
<p>如果还是比较困难，则用redis记录每次消费并生成全局唯一键&lt;id,message&gt;，每次消费查询一次redis，存在消费记录则不进行消费（处理）</p>
<h3 id="熔断与服务降级"><a href="#熔断与服务降级" class="headerlink" title="熔断与服务降级"></a>熔断与服务降级</h3><p>当请求某个服务超时或是响应过慢，并在一定时间内次数达到一定阈值，为了防止调用链路响应过长而引发的服务雪崩，我们将暂时不去请求这个服务， 而是调用降级方法，并下线该服务。期间一般会在过去一定时间后，尝试再次请求该服务，获得响应后才会上线，不然都将是调用降级方法。</p>
<p>例如Hystrix，它有一个滑动时间窗的概念，在这个滑动的时间窗内（默认20s），错误率达到阈值（默认50%）则将打开熔断器，并经过一段时间之后（默认5s）再次执行一次检测是否应该打开熔断器。<br>熔断器在打开期间，调用此服务将直接返回失败（服务降级），不再远程调用。</p>
<blockquote>
<p>注意<br>服务降级不一定伴随着熔断出现，他还可能是开关降级、限流降级。<br>但是熔断是一定会出现服务降级的。<br>即熔断是服务降级的子集</p>
</blockquote>
<blockquote>
<p>ps: 服务雪崩是指由于调用链路当中，下游的服务响应太慢或者超时导致上游服务的请求得不到释放， 逐渐导致连接数达到上限从而又对上游服务造成影响 ，如此往复直到最上游服务难以承受压力（超过最大连接数等）</p>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MQ</tag>
        <tag>Micro Service</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程——双检锁单例模式</title>
    <url>/2021/06/16/juc-dcl-singleton/</url>
    <content><![CDATA[<p>记录一下双检锁单例模式是怎么一回事</p>
<span id="more"></span>
<blockquote>
<p>封面 pixiv id 64535234</p>
</blockquote>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>懒汉单例模式是无法保证线程安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <br>            <span class="hljs-comment">//多个线程同时通过if判断新建实例，违反单例的初衷</span><br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>即当线程A通过if判断，但还未创建实例，此时线程B也能够通过if判断，那么就会对重复创建实例违反单例的初衷。</p>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>那么我们为了保证线程安全，引入synchronized进行同步处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//此时最多只会有一个线程进入if判断中</span><br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时就只有一个线程能够获取锁进入到if判断创建实例了。</p>
<hr>
<blockquote>
<ul>
<li>synchronized 偏向锁，自旋锁，轻量级锁，重量级锁</li>
</ul>
<p>通过 synchronized 加锁，第一个线程获取的锁为偏向锁，这时有其他线程参与锁竞争，升级为轻量级锁，其他线程通过循环的方式尝试获得锁，称自旋锁。若果自旋的次数达到一定的阈值，则升级为重量级锁。</p>
<p>需要注意的是，在第二个线程获取锁时，会先判断第一个线程是否仍然存活，如果不存活，不会升级为轻量级锁。</p>
</blockquote>
<h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>可是现在由于同步处理导致每次获取实例都需要竞争获取锁导致效率非常低下，<br>所以我们应该在最外面做一次if判断来让大多数时候直接return实例而不是进行锁的竞争。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//为了快速返回而不进入锁的竞争</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <span class="hljs-comment">//以当前类作为锁</span><br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//此时最多只会有一个线程进入if判断中</span><br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>而这就是双检锁（双重检查锁，Double check lock，DCL）。</p>
<h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><p>但这里其实还是没有彻底解决多线程的问题，因为new Object分为三个步骤：</p>
<ul>
<li>分配内存空间 </li>
<li>初始化对象信息</li>
<li>将内存空间引用赋值给变量</li>
</ul>
<p>如果这当中指令重排了，在还没有初始化对象的时候就把地址赋值给了变量，此时在最外层的if判断变量不为空，因为有地址，<br>这时候就会拿到一个未经初始化的变量。<br>所以我们还需要用volatile修饰变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton; <span class="hljs-comment">//避免指令重排序</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//为了快速返回而不进入锁的竞争</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <span class="hljs-comment">//以当前类作为锁</span><br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//此时最多只会有一个线程进入if判断中</span><br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<blockquote>
<ul>
<li>volatile  </li>
</ul>
<p><img src="/.moe//volatile.png" alt="volatile"></p>
<p>在多线程环境下，保证变量的可见性。使用了 volatile 修饰变量后，在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。  </p>
<p>禁止 JVM 指令重排序。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin使用记录01</title>
    <url>/2021/12/17/lean-kotlin-01/</url>
    <content><![CDATA[<p>Kotlin是一个完全兼容java的jvm语言，但不是说什么地方都跟java一样，只是说可以完全调用java。而也有于此，导致Kotlin一些使用方面需要注意一些东西，例如标准库不一定是跟JDK用法相同。<br>不过我也没有打算完全记录，可能更多的还是做个TODO列表<del>防健忘</del></p>
<span id="more"></span>
<blockquote>
<p>封面<br>逆光剑，Fate/hollow ataraxia中バゼット使用的武器之一。<br>在Fate/unlimited codes中与Lancer的Gae Bolg同时发动会有奇效：由于皆为因果逆转宝具——注定命中对方的心脏；后发但会先贯穿对方。两方会由于逆转因果失败而同时受到宝具伤害后倒地。</p>
</blockquote>
<h2 id="Kotlin的标准库"><a href="#Kotlin的标准库" class="headerlink" title="Kotlin的标准库"></a>Kotlin的标准库</h2><p>Kotlin的标准库是有别于Java的，注意调用时点进去看是什么包下面的。<del>其实好像也就想到了list跟map</del></p>
<h3 id="List-Map等"><a href="#List-Map等" class="headerlink" title="List, Map等"></a>List, Map等</h3><p>List和Map是有些非常方便的方法构建的，<code>listOf(&quot;xxx&quot;, &quot;xxx&quot;)</code>, <code>mapOf(&quot;xxx&quot; to &quot;xxx&quot;, &quot;xxx&quot; to &quot;xxx&quot;)</code>，这些用起来非常爽快。但需要注意这里返回的类型是Kotlin下的List跟Map，它所提供的方法很有限，都是不可变的方法。但具体返回的对象则不一定是不可变的，具体点进方法内看就知道了。<br>那么我们需要一个可变的List或是Map时就需要让方法返回MutableList或是MutableMap的对象，可以用<code>mutableOfList()</code>或<code>mutableOfMap()</code>，当然你也可以用is去看是不是某类型的实例，大多其实还是返回的JDK里面的list跟map。</p>
<h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>Kotlin要说我感到最爽的东西，大概除了协程就是这个了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> MarkdownUtil &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> formatChar = <span class="hljs-string">&quot;_*[]()~`&gt;#+-=|&#123;&#125;.!&quot;</span>.toCharArray()<br>    <br>    <span class="hljs-comment">//扩展函数，可以直接就等于一个方法，也可以调用该类内部方法，this指代的就是当前调用这个方法的String对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">format2Markdown</span><span class="hljs-params">()</span></span>: String = MarkdownUtil.format(<span class="hljs-keyword">this</span>)<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">format</span><span class="hljs-params">(target: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>        <span class="hljs-keyword">var</span> result = target<br>        <span class="hljs-keyword">for</span> (c <span class="hljs-keyword">in</span> formatChar) &#123;<br>            result = result.replace(c.toString(), <span class="hljs-string">&quot;\\<span class="hljs-variable">$c</span>&quot;</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的例子是我写Telegram Bot时写的一个方法，用来转换掉markdown的特殊字符，调用时只需要<code>&quot;Some String&quot;.format2Markdown()</code>，这就像String类扩展了一个方法一样，当你有许多这样的方法的时候，也许你就可以像链式调用一样写起来特别爽快了。</p>
<p>这样对于一些非自己项目内的代码进行非常简单的扩展也会大大增加写代码的效率，而不需要额外调用一个工具类对该变量做处理（不需要管其他工具类，只要点出来就好了）等等。</p>
<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>Kotlin的Lambda整体感觉是要强于java很多的，java很多情况下的推断都不太行导致很多地方没法使用，另外一个是Kotlin对Lambda的支持要能够放入更多的地方，例如你可以直接将一串Lambda赋值于一个变量而不需要特别的写一个函数接口，拿到的一个类型就是Unit。换句话说，函数是kotlin的一等公民。</p>
<h2 id="Type-safety"><a href="#Type-safety" class="headerlink" title="Type safety"></a>Type safety</h2><p>类型安全也是Kotlin的一个区别于java的特色，虽然java其实可以用Optional作为代替，但是Kotlin也是可以使用的。  </p>
<p>但Kotlin自身的类型安全是你声明时是否声明一个空变量，而后编译的时候就给你检测报错，并且强制要求你做一次判空，但Kotlin对判空进行了简化，用<code>value?.doSomeThing()</code>的方式先做判空，若是空则不会调用后面的<code>doSomeThing</code>方法。</p>
<p>但实际上强制你做类型声明的时候生命是否为空也是很烦人的，因为后面你到哪里都要做一次判空，虽然Kotlin能够推断当前的变量是否为空而后不需要判空，但他无法对变量内部的成员变量做判断，就算你判空过一次他也无法后面不需要判空，虽然可以赋值到当前的变量当中但是仍然是比较麻烦的。（这个后面类型推断会提到）</p>
<p>那么这个时候其实可以考虑用Java写POJO类，Kotlin对Java类都是不做强制要求判空的。</p>
<p>或者就需要煞费苦心分别分开不同的类比如，对接其他API的时候实际上返回的是一个聚合了很多东西的类，不同情况下不同的字段是有可能空或者非空的，如果都用一个类就会造成几乎所有字段都是可能空的尴尬，那么分开几个类型来接受就能够确切的知道当前的哪些字段是否空了。<br>比如两种响应数据都含有data字段，但是data里面的name字段其中一种响应是不存在的；或者是可空的，另一种是一定非空，那么我们可以分成两个类去分别维护这两个响应数据结构，这样也许就比较符合我们想要的<code>type-safe</code>了。</p>
<h2 id="推断"><a href="#推断" class="headerlink" title="推断"></a>推断</h2><p>Kotlin的推断能力在上面也有提到，再结合IDE就会边得异常爽快，例如上面提到的，如果这个变量进行过判空操作，后面就会自动的认为这个变量是非空的而不需要再次强制要求判空。<br>实际这个是推断当前变量为非空类型，所以后面不需要判空。</p>
<p>又比如java当中非常繁琐的一种操作是<code>if a instanceOf B</code>，<code>b = (B)a</code>，然后用这个b变量操作，而Kotlin直接<code>is</code>一次判定为真后自动推断你这个变量就是某类型，而后可以直接用该变量调用该类型的方法。  </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">is</span> B) &#123;<br>    a.bClassMethod()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而这些在IDE上是都有提示的，最典型的就是<code>val a = &quot;123&quot;</code>在IDE当中是可以显示a的类型而不需要再手动定义类型了，当然你也可以显式声明类型。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>这个留在最后讲其实主要我也不是特别熟，但不得不说这也是Kotlin的一大爽点吧。<br>Kotlin的协程是一种无栈协程，他没有直接纳入Kotlin标准库当中，这样可以提高灵活性而不需要被标准库绑架。<br>它比起大多的异步编程框架还是爽上不少的，毕竟可以直接写类似同步代码的代码达到异步编程的效果实在太棒了。但说实话我在写自己项目时，也有一些不解的地方，或者说我还不太了解它的运行轨迹。</p>
<p>现在了解到的就是，实际上他是做了一个标记，类似占位符，提交这段代码到线程执行，然后马上看执行结果，若是完成则返回结果，否则就是一个占位符（我没有看过源码，也不打保票就是这样，毕竟我自己写代码的时候还是有一些问题的），而只有当查看执行结果没有完成时才算是开始跑协程，不然跟普通跑代码区别不是很大。</p>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ul>
<li>在运行一些长时间保持运行的项目当中，容易造成内部卡死。<br>  e.g.  <figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">scope.launch &#123;<br>    <span class="hljs-keyword">while</span> (isActive) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            feedAndSend(rss, group)<br>            delay(<span class="hljs-number">1000</span> * <span class="hljs-number">60</span>)<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            log.error(e) &#123; <span class="hljs-string">&quot;执行订阅出错。&quot;</span> &#125;<br>        &#125;<br>    &#125;<br>    log.warn &#123; <span class="hljs-string">&quot;Coroutine was inactive.&quot;</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>另外还有类似接收到服务器发送的信息进行处理，运行久了就会无报错信息卡住不动，但最初的是时候我使用Dispatch.IO，之后我自己构建线程池指定队列长度以及线程配置后就还没发生过问题。</li>
</ul>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor处理阻塞问题笔记</title>
    <url>/2020/03/03/lean-pulishOn-of-reactor/</url>
    <content><![CDATA[<p>其实本来想要记录问题的过程，但奈何自己也说不太好XD</p>
<span id="more"></span>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>由于接触Vert.x以及阅读其文档后，了解到异步编程下是不能够阻塞主线程的，不然异步将失去意义。</p>
<p>我们需要做的是将这些阻塞线程移到其他线程进行处理。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>利用Mono或是Flux的PublishOn方法将之后调用的方法都移动到其他线程进行处理。</p>
<ul>
<li><p><code>publishOn</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Mono&lt;T&gt; <span class="hljs-title function_">publishOn</span><span class="hljs-params">(Scheduler scheduler)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Flux&lt;T&gt; <span class="hljs-title function_">publishOn</span><span class="hljs-params">(Scheduler scheduler)</span>;<br></code></pre></td></tr></table></figure>

<p>其中<code>Scheduler</code>可用<code>Schedulers.parallel()</code>或<code>Schedulers.single()</code>进项创建或是其他方法，其中<code>single</code>和<code>parallel</code>是有一些区别的。</p>
<ul>
<li><p><code>single</code></p>
<p>这一条调用链下不会同时执行，并且只有这条调用链执行完成后才会再次被调用</p>
</li>
<li><p><code>parallel</code></p>
<p>与上面相反，调用链会在同时执行</p>
</li>
</ul>
<p>下面是测试代码</p>
<p><del>本人只是刚开始玩reactor，程序写的很蹩脚XD</del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    AtomicReference&lt;Employee&gt; employeeAR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(); <span class="hljs-comment">//&lt;1&gt;</span><br>    <span class="hljs-type">Scheduler</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> Schedulers.single(); <span class="hljs-comment">//&lt;2&gt;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>      Mono.just(<span class="hljs-number">1</span>)<br>          .publishOn(scheduler)<br>          .map(x -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              Thread.sleep(<span class="hljs-number">1000</span>);<br>              System.out.println(finalI + <span class="hljs-string">&quot;-&quot;</span> + Thread.currentThread()<br>                  .getName() + <span class="hljs-string">&quot;-A&quot;</span>); <span class="hljs-comment">//&lt;3&gt;</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              e.printStackTrace();<br>            &#125;<br>            <span class="hljs-type">Employee</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> buildEmployee();<br>            employeeAR.set(emp); <span class="hljs-comment">//&lt;1&gt;</span><br>            <span class="hljs-keyword">return</span> emp;<br>          &#125;)<br>          .map(x -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              System.out.println(finalI + <span class="hljs-string">&quot;-&quot;</span> + Thread.currentThread()<br>                  .getName() + <span class="hljs-string">&quot;-B&quot;</span>); <span class="hljs-comment">//&lt;3&gt;</span><br>              Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> x;<br>          &#125;)<br>          .map(x -&gt; &#123;<br>            System.out.println(finalI + <span class="hljs-string">&quot;-&quot;</span> + Thread.currentThread()<br>                .getName() + <span class="hljs-string">&quot;-C&quot;</span>); <span class="hljs-comment">//&lt;3&gt;</span><br>            <span class="hljs-keyword">return</span> employeeAR.get().getAccountId(); <span class="hljs-comment">//&lt;1&gt;</span><br>          &#125;)<br>          .subscribe(System.out::println);<br><br>      System.out.println(Thread.currentThread()<br>          .getName());  <span class="hljs-comment">//&lt;3&gt;</span><br>    &#125;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>) System.in.read();<br>    System.out.println(<span class="hljs-string">&quot;your char is: &quot;</span> + c);<br>  &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>&lt;1&gt; 因为涉及到匿名方法中的变量的再次调用，所以用到AtomicReference进行储存。</li>
</ul>
<p>下面是<code>single</code>的运行结果</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">main</span><br><span class="hljs-attribute">main</span><br><span class="hljs-attribute">main</span><br><span class="hljs-attribute">main</span><br><span class="hljs-attribute">main</span><br><span class="hljs-attribute">0</span>-single-<span class="hljs-number">1</span>-A<br><span class="hljs-attribute">0</span>-single-<span class="hljs-number">1</span>-B<br><span class="hljs-attribute">0</span>-single-<span class="hljs-number">1</span>-C<br><span class="hljs-attribute">123</span><br><span class="hljs-attribute">1</span>-single-<span class="hljs-number">1</span>-A<br><span class="hljs-attribute">1</span>-single-<span class="hljs-number">1</span>-B<br><span class="hljs-attribute">1</span>-single-<span class="hljs-number">1</span>-C<br><span class="hljs-attribute">123</span><br><span class="hljs-attribute">2</span>-single-<span class="hljs-number">1</span>-A<br><span class="hljs-attribute">2</span>-single-<span class="hljs-number">1</span>-B<br><span class="hljs-attribute">2</span>-single-<span class="hljs-number">1</span>-C<br><span class="hljs-attribute">123</span><br><span class="hljs-attribute">3</span>-single-<span class="hljs-number">1</span>-A<br><span class="hljs-attribute">3</span>-single-<span class="hljs-number">1</span>-B<br><span class="hljs-attribute">3</span>-single-<span class="hljs-number">1</span>-C<br><span class="hljs-attribute">123</span><br><span class="hljs-attribute">4</span>-single-<span class="hljs-number">1</span>-A<br><span class="hljs-attribute">4</span>-single-<span class="hljs-number">1</span>-B<br><span class="hljs-attribute">4</span>-single-<span class="hljs-number">1</span>-C<br><span class="hljs-attribute">123</span><br></code></pre></td></tr></table></figure>

<p>将&lt;2&gt;中<code>single</code>改为<code>parallel</code></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">main</span><br><span class="hljs-attribute">main</span><br><span class="hljs-attribute">main</span><br><span class="hljs-attribute">main</span><br><span class="hljs-attribute">main</span><br><span class="hljs-attribute">0</span>-parallel-<span class="hljs-number">1</span>-A<br><span class="hljs-attribute">3</span>-parallel-<span class="hljs-number">4</span>-A<br><span class="hljs-attribute">2</span>-parallel-<span class="hljs-number">3</span>-A<br><span class="hljs-attribute">4</span>-parallel-<span class="hljs-number">5</span>-A<br><span class="hljs-attribute">0</span>-parallel-<span class="hljs-number">1</span>-B<br><span class="hljs-attribute">3</span>-parallel-<span class="hljs-number">4</span>-B<br><span class="hljs-attribute">2</span>-parallel-<span class="hljs-number">3</span>-B<br><span class="hljs-attribute">1</span>-parallel-<span class="hljs-number">2</span>-A<br><span class="hljs-attribute">1</span>-parallel-<span class="hljs-number">2</span>-B<br><span class="hljs-attribute">4</span>-parallel-<span class="hljs-number">5</span>-B<br><span class="hljs-attribute">0</span>-parallel-<span class="hljs-number">1</span>-C<br><span class="hljs-attribute">1</span>-parallel-<span class="hljs-number">2</span>-C<br><span class="hljs-attribute">3</span>-parallel-<span class="hljs-number">4</span>-C<br><span class="hljs-attribute">4</span>-parallel-<span class="hljs-number">5</span>-C<br><span class="hljs-attribute">2</span>-parallel-<span class="hljs-number">3</span>-C<br><span class="hljs-attribute">123</span><br><span class="hljs-attribute">123</span><br><span class="hljs-attribute">123</span><br><span class="hljs-attribute">123</span><br><span class="hljs-attribute">123</span><br></code></pre></td></tr></table></figure>

<p>观察代码中&lt;3&gt;，我们可以发现调用链当中是按照顺序执行的（我最开始以为会平行执行调用链中的方法，但并不是），而且主线程也没有被阻塞，能够快速输出当前线程名称，由此可见已经达到我们最初的目的了——不阻塞主线程。</p>
</li>
</ul>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>在这里我用的是Spring WebFlux，而其中会用到netty，其中有一个Eventloop模块，这是由单个线程运行的模块，这个单线程就是由我们程序所运行的主线程来担当。</p>
<p>Eventloop会重复检查当前有没有事件产生，若有则会接收该事件并运行相应的事件响应，也就是发布订阅模式，而如果我们在其中一个调用该事件的响应方法中等待（阻塞）过久，就会导致我们无法快速处理后续产生的事件，只能够加多线程进行快速处理，这就又回到了非异步编程当中去了。</p>
<p>所以能够快速响应才能够体现出异步编程的优势。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://github.com/reactor/reactor-core/issues/1756">Is there a standard way to solve blocking that must happen.</a></li>
<li><a href="https://stackoverflow.com/questions/56706308/how-to-handle-blocking-calls-when-using-reactor-in-a-jax-rs-powered-server">How to handle blocking calls when using reactor in a JAX-RS-powered server?</a></li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li><input disabled type="checkbox"> 测试嵌套调用publishiOn是什么情况  </li>
<li><input disabled type="checkbox"> 是否是调用一次publishOn后，后面的链式调用都是在另一条线程，是否需要再次调用一次pubulishOn保证之后的一次阻塞操作也不在主线程当中  </li>
<li><input disabled type="checkbox"> 补充详细Evenloop  </li>
<li><input disabled type="checkbox"> 寻找更加优雅的方式，或者看看这种链式调用是不是也是一个不太好的地方  </li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reactor</tag>
        <tag>Webflux</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>学习JPA笔记——使用MetaModel实现Typesafe</title>
    <url>/2020/10/06/learning-jpa-01/</url>
    <content><![CDATA[<p>本篇主要说 Typesafe，下一篇讲一下 JPA 构建复杂查询。项目<del>极简</del>代码<a href="https://github.com/NatsuSai/spring-data-jpa-demo">在这</a></p>
<span id="more"></span>
<blockquote>
<p>封面：动画「ガーリー・エアフォース」#08的 EDCard，算是原作插画师<a href="https://twitter.com/asagi_0398">@遠坂あさぎ</a>的贺图，每集一张。<br>有趣的是因为最高机密的特性导致男主看到的样子和幼馴染一样，而此时他的幼馴染正生着气，所以标题叫不高兴的最高机密w</p>
</blockquote>
<p>最近看了<a href="https://github.com/hantsy/helidon-sample">@hantsy</a>大大在V站的帖子（<a href="https://www.v2ex.com/t/688051#reply70">这里</a>、<a href="https://www.v2ex.com/t/688051#reply70">这里</a>），<br>就开始心血来潮想要看看 JPA 怎么玩，另外就是大大所说的 Typesafe 要这么实现。</p>
<blockquote>
<p>注意：这里不会对JPA大多的基础知识进行说明，文章本意是做一次笔记，必要时请充分发挥自主能动性进行查找学习</p>
</blockquote>
<h2 id="Typesafe"><a href="#Typesafe" class="headerlink" title="Typesafe"></a>Typesafe</h2><p>我的理解是不要那种无法编译时无法检验出错误或者 IDE 无法帮助我们检验错误的字符串，而这里比较突出的就是字段名。</p>
<p>我司其实也是内部写了一套 <a href="https://github.com/tanqimin/MyFavsORM">orm</a>，只是基本不在意 Typesafe，而更加注重方便直接编写复杂 sql 而已。</p>
<p>而没有编译时的检测或者是 IDE 的检测，就难免出现 Typo，更加糟糕的是后期维护时的修改会造成一种我还有哪里用到了这个字段的尴尬状况，一旦遗漏就只能等运行时才可以检测出了。</p>
<p>为了解决这一状况，我们可以用到 MetaModel 生成器，例如 Hibernate 就有相应的生成器<code>jpamodelgen</code>（这类 MetaModel 生成器是为了实现 JPA2.0 标准的，具体我没有细查）</p>
<p>除了 Hibernate 以外，EclipseLink 也有这类生成器，各位可以自己去玩玩。我由于直接用 SpringDataJpa，而 spring 默认使用 Hibernate，所以就没有折腾别的了。</p>
<h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>下面是我整合了Lombok生成器的配置，仅供参考。也可以看看<a href="https://docs.jboss.org/hibernate/stable/jpamodelgen/reference/en-US/html_single/">这篇文章</a>，有多种玩法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>    ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        ...<br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-jpamodelgen<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.4.21.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 如果不是用SpringDataJpa的话，需要额外引入下面的依赖 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.persistence<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.persistence-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>                    &lt;/annotationProcessorPaths &gt;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.bsc.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-processor-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>process<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>process<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">processors</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">processor</span>&gt;</span>org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor<span class="hljs-tag">&lt;/<span class="hljs-name">processor</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">processors</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-jpamodelgen<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.4.21.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>添加完后，在实体类添加@Entity和@Id的注解使生成器生效，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Post</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.AUTO)</span><br>    <span class="hljs-type">int</span> id;<br>    String title;<br>    String content;<br>    <span class="hljs-meta">@Enumerated(EnumType.STRING)</span><br>    <span class="hljs-type">Status</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> Status.DRAFT;<br>    LocalDateTime createdAt;<br>    <span class="hljs-meta">@Transient</span><br>    String excludeColumn;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span>&#123;DRAFT, PUBLISHED&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Post <span class="hljs-title function_">of</span><span class="hljs-params">(String title, String content)</span> &#123;<br>        <span class="hljs-type">Post</span> <span class="hljs-variable">post</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Post</span>();<br>        post.setCreatedAt(LocalDateTime.now());<br>        post.setTitle(title);<br>        post.setContent(content);<br><br>        <span class="hljs-keyword">return</span> post;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>添加完后对代码进行编译，生成器则会找到该注解的类生成这样的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Generated(value = &quot;org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor&quot;)</span><br><span class="hljs-meta">@StaticMetamodel(Post.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Post_</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingularAttribute&lt;Post, LocalDateTime&gt; createdAt;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingularAttribute&lt;Post, Integer&gt; id;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingularAttribute&lt;Post, String&gt; title;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingularAttribute&lt;Post, String&gt; content;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingularAttribute&lt;Post, Status&gt; status;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CREATED_AT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;createdAt&quot;</span>;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;id&quot;</span>;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TITLE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;title&quot;</span>;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONTENT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;content&quot;</span>;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">STATUS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;status&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>而当我们运行程序时，SingularAttribute 类型的对象则会被自动赋值，之后在调用 JPA 的 API 时则可以作为参数传入，而不是传入字符串了。<br>调用时看起来是这样子的：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">repository.findAll<span class="hljs-function"><span class="hljs-params">((Specification&lt;Post&gt;) (root, criteriaQuery, builder) -&gt; builder.like(root.get(Post_.title), <span class="hljs-string">&quot;%Test%&quot;</span>))</span></span><br></code></pre></td></tr></table></figure>
<p><del>我说什么来着，不用字符串</del><br>其实这里就不太需要追求这些，而字段这些是带关联性的，会在好多个地方出现，有必要对其进行检测。对于人类而言，检测总是会犯错，所以这些最好是交由机器来帮忙，也能够让我们更加关注业务。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/hantsy/helidon-sample/blob/master/mp-jpa/src/main/java/com/example/PostRepository.java">helidon-sample</a> @ <a href="https://github.com/hantsy">hantsy</a><br><a href="https://docs.jboss.org/hibernate/stable/jpamodelgen/reference/en-US/html_single/">Hibernate JPA 2 Metamodel Generator</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JPA</tag>
        <tag>ORM</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>学习JPA笔记——构建复杂查询</title>
    <url>/2020/10/06/learning-jpa-02/</url>
    <content><![CDATA[<p>本篇介绍两种 JPA 做复杂查询的方法，一个是用 SpringDataJPA 实现， 一个是用 Java EE 实现。</p>
<span id="more"></span>
<blockquote>
<p>封面：同上篇，这次前景就是最高机密 Viper Zero。<del>嗯，没啥问题，每集一张，只是PS了</del></p>
</blockquote>
<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><h3 id="JPA以及其他类似东西之间的关系"><a href="#JPA以及其他类似东西之间的关系" class="headerlink" title="JPA以及其他类似东西之间的关系"></a>JPA以及其他类似东西之间的关系</h3><p>在进入正题之前还是稍微提一下这几个东西之间的关系。<br>首先JPA是一种规范，Java EE 中有把这种规范抽象出来的接口，具体实现是看用的什么框架，可以是 Hibernate 或者是 EclipseLink 等。<br>而这之中 Spring 又对 Java EE 中的接口再次封装，以更好地整合进 Spring 体系当中，但 SpringDataJPA 仍然是个抽象，具体实现仍然是看选型的框架。<br>但日常中，由于 SpringDataJPA 默认是 Hibernate 实现，所以一般场合基本相当于 Hibernate。</p>
<h3 id="个人对于数据库复杂查询的理解或看法"><a href="#个人对于数据库复杂查询的理解或看法" class="headerlink" title="个人对于数据库复杂查询的理解或看法"></a>个人对于数据库复杂查询的理解或看法</h3><p>对于联表这些事情我个人的感受来说是极为痛苦的，表面上可以不多此查询数据库，不查询多余数据，不需要程序做多次遍历。<br>其实在一些压力不大的场景中，这些都显得很无所谓。多次连接有缓存，多次遍历实际消耗也不大，多余数据实际上做 join 的时候就会拿过来，join 中加入条件也和第二次查询加入条件差不多。<br>但实际上最麻烦的，是当真正数据库压力上来了，这些操作都没有太大意义，最后还是会在数据库和程序此之间加入缓存，把数据库做的很多事情放到程序当中去做，尽量减低数据库压力。<br>而此时你就会发现之前做的联表查询之类的就像是外来物一样格格不入。</p>
<p>所以我对此也非常欣赏DDD的设计美感。</p>
<h2 id="SpringDataJPA"><a href="#SpringDataJPA" class="headerlink" title="SpringDataJPA"></a>SpringDataJPA</h2><p>SpringDataJPA 的复杂查询除了直接写 sql，按照规则定义 Repository 接口方法以外，还可以使用Specification做查询。</p>
<h3 id="Specification"><a href="#Specification" class="headerlink" title="Specification"></a>Specification</h3><p>这是SpringDataJPA抽象出的一个接口，故并不一定通用于其他JPA的实现。<br>该接口重点在于<code>toPredicate</code>方法，该方法将创建一个 where 语句对象。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Specification</span>&lt;<span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Serializable</span> &#123;<br><br>    ...<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a WHERE clause for a query of the referenced entity in form of a  Predicate for the given</span><br><span class="hljs-comment">     * Root and CriteriaQuery.</span><br><span class="hljs-comment">     */</span><br>    @Nullable<br>    Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里我只做简要说明，以便于理解，仅供参考。</p>
<ul>
<li>root：<br>  一般指实体类本身，包装成 Root 对象, 可由query.from(Post.class)得到<code>Root&lt;Post&gt;</code>，Java EE 会提到。</li>
<li>query：<br>  sql语句对象，一般在此方法内部不做调用，Java EE 会给一些用于理解的调用。</li>
<li>criteriaBuilder：<br>  用于构建条件语句。</li>
</ul>
<blockquote>
<p>个人建议是不要管我说的这些，真要去理解就看源码注释，或者看下面 Java EE 的代码，更能够理解。</p>
</blockquote>
<h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>首先我们创建一个 Repository 接口，并继承<code>JpaSpecificationExecutor&lt;T&gt;</code>以获得复杂查询的能力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PostRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaSpecificationExecutor</span>&lt;Post&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后我们运用 java8 所带来的新特性，使用 lambda 构建一个匿名 Specification 的实现类，并实现 toPredicate 方法。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">repository.findAll(<br>    (Specification&lt;Post&gt;) (root, criteriaQuery, builder) -&gt; &#123; <br>        // <span class="hljs-keyword">where</span> title <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%Test%&#x27;</span>;<br>        <span class="hljs-keyword">return</span> builder.<span class="hljs-keyword">like</span>(root.<span class="hljs-keyword">get</span>(Post_.title), &quot;%Test%&quot;)<br>        // 如果是多个条件，例如 <span class="hljs-keyword">where</span> title <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%Test%&#x27;</span> <span class="hljs-keyword">and</span> content <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%Test%&#x27;</span> <span class="hljs-keyword">and</span> id &lt; <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">return</span> builder.<span class="hljs-keyword">and</span>(builder.<span class="hljs-keyword">like</span>(root.<span class="hljs-keyword">get</span>(Post_.title), &quot;%Test%&quot;), builder.<span class="hljs-keyword">like</span>(root.<span class="hljs-keyword">get</span>(Post_.content), &quot;%Test%&quot;), builder.le(root.<span class="hljs-keyword">get</span>(Post_.id), <span class="hljs-number">10</span>))<br>        // 而如果我们没有做 Typesafe，那么就会变成这样<br>        <span class="hljs-keyword">return</span> builder.<span class="hljs-keyword">like</span>(root.<span class="hljs-keyword">get</span>(&quot;title&quot;), &quot;%Test%&quot;)<br>    &#125;<br>);<br></code></pre></td></tr></table></figure>
<p>使用起来其实没什么困难，基本举一反三，其他的复杂查询我暂时没研究，主要是觉得可以避开用别的方法操作，或者提到程序中操作。</p>
<h2 id="Java-EE"><a href="#Java-EE" class="headerlink" title="Java EE"></a>Java EE</h2><p>实际上，SpringDataJPA 是对 Java EE 原本的 JPA 抽象再次包装了一层，所以这个可以说是原汁原味了。</p>
<h3 id="Getting-Stated"><a href="#Getting-Stated" class="headerlink" title="Getting Stated"></a>Getting Stated</h3><p>由于我主要使用 SpringDataJPA 所以摘抄了一段代码，<a href="https://github.com/hantsy/helidon-sample/blob/master/mp-jpa/src/main/java/com/example/PostRepository.java">出处</a>。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">//需要对此进行注入<br>private final EntityManage entityManager;<br><br>String q;<br><span class="hljs-type">int</span> <span class="hljs-keyword">offset</span>, <span class="hljs-keyword">limit</span>;<br><br>CriteriaBuilder cb = this.entityManager.getCriteriaBuilder();<br>// <span class="hljs-keyword">create</span> query<br>CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.<span class="hljs-keyword">class</span>);<br>// <span class="hljs-keyword">set</span> the root <span class="hljs-keyword">class</span><br>Root&lt;Post&gt; root = query.<span class="hljs-keyword">from</span>(Post.<span class="hljs-keyword">class</span>);<br><br>// <span class="hljs-keyword">if</span> keyword <span class="hljs-keyword">is</span> provided<br><span class="hljs-keyword">if</span> (q != <span class="hljs-keyword">null</span> &amp;&amp; !q.trim().isEmpty()) &#123;<br>    // 这里其实就是上面 toPredicate 返回的对象作为参数传入<span class="hljs-keyword">where</span>方法当中，所以里面就和上面的实现没有什么太大区别。<br>    query.<span class="hljs-keyword">where</span>(<br>            cb.<span class="hljs-keyword">or</span>(<br>                    cb.<span class="hljs-keyword">like</span>(root.<span class="hljs-keyword">get</span>(Post_.title), &quot;%&quot; + q + &quot;%&quot;),<br>                    cb.<span class="hljs-keyword">like</span>(root.<span class="hljs-keyword">get</span>(Post_.content), &quot;%&quot; + q + &quot;%&quot;)<br>            )<br>    );<br>&#125;<br>//<span class="hljs-keyword">perform</span> query<br><span class="hljs-keyword">return</span> this.entityManager.createQuery(query)<br>        .setFirstResult(<span class="hljs-keyword">offset</span>)<br>        .setMaxResults(<span class="hljs-keyword">limit</span>)<br>        .getResultList();<br></code></pre></td></tr></table></figure>

<ul>
<li>EntityManager<br>  实体管理类，用于与持久化上下文进行互动，核心类。</li>
</ul>
<p>其他几个 Root、CriteriaQuery、CriteriaBuilder 作用同上，毕竟spring只是做了封装。<br>看完上面代码，大致就能够了解清楚这几个类分别是怎么使用的了，总体来说其实比上面spring的实现所接触到的东西更加全面一些，也能够理解这几个类互相是怎么作用的了。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/hantsy/helidon-sample/blob/master/mp-jpa/src/main/java/com/example/PostRepository.java">helidon-sample</a> @ <a href="https://github.com/hantsy">hantsy</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JPA</tag>
        <tag>ORM</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Over the wall</title>
    <url>/2020/12/07/over-the-wall/</url>
    <content><![CDATA[<p>I will record here some information or opinions that I believe.<br>Everything is selected based on my subjective judgment.</p>
<span id="more"></span>
<blockquote>
<p>封面 我的头像出处，《Lian》当中的女主铃音，头像以及本封面都是碟子附赠的图片。片子非常意识流，那种感觉就像第一次看 eva 一样，有点跟不上节奏，或者说觉得非常混沌。</p>
</blockquote>
<hr>
<p><a href="https://www.v2ex.com/t/689630?p=1#r_9241365">Link</a></p>
<blockquote>
<p>首先，把移民和工作分开：很多人移民了还是要辛苦工作<br>其次，把移民和 “改变命运” 这件事分开：很多人移民了并没有太大的改命<br>然后，把移民和与众不同这件事分开：很多比你条件差的人也成功了<br>然后，把移民和鹤立鸡群这件事分开：即使你移民成功了别人也未必羡慕<br>然后，把移民和生活中任何一件事联系起来：它就像任何一次部门间的工作调动一样平常，组织捞人 捞到你了，组织说让你去海外你就去了，就完事了（和你的个人素质并无关系：比你的英文水平好很多的人，其实也没移民；比你 IT 能力再高的人，其实也没移民；怎么就论到你移民了呢？是的，就是轮到你了。）</p>
<p>并不高不可攀，甚至就像喝水</p>
<p>然后，你会发现 V2EX 其实并不是一个特别适合讨论移民这件事的 BBS，尤其是在增强移民信心和让移民可行性落地的方面：盖因它无法像讨论一件普普通通的事情一样讨论移民，它没这心胸。</p>
</blockquote>
<p><a href="https://www.v2ex.com/t/731552?p=2#r_9874141">Link</a></p>
<blockquote>
<p>不想反驳一些人的观点，毕竟每个人都有表达自己观点的权利。</p>
<p>但是，作为一个个体，你需要明确：</p>
<p>1 、你的一辈子很短，你必须优先考虑眼前的幸福，而不是未来潜在的幸福。比如，我承认中国在改善、在发展，但是在可见的未来几十年，许多问题依然不会得到解决（ e.g.建立独立的司法体系、健全对弱势群体的保护）。这是一个价值观选择题：你选择去伟大地建设这个国家，还是优先保护自己和家人？很遗憾，我比较自私，我也不是伟人，我选择短期内更能保护我个人利益（ e.g.有健全的劳动法、有工会、可以自由访问互联网并且自由交流思想）的地方。</p>
<p>2 、国家是一个政治概念，是一个“协议”、“合同”，而不是一种与生俱来的强加于个体的道德义务。有兴趣的可以参考这里的讨论： <a href="https://www.zhihu.com/question/48440859">https://www.zhihu.com/question/48440859</a> 。所以，不要被这种政治概念和集体思想绑架，否则你就是韭菜——或者你是站在有资源的那一边，可以利用这个概念去绑架别人、割别人韭菜。</p>
<p>3 、移民与否，取决于你在哪里更有优势、能活得更好。我认识的大部分回国的同学，都是在国内非富即贵的。我想了想，似乎非常合理：因为他们回去可以轻而易举地活得很好甚至随意割别人韭菜。如果你也是有本事割别人韭菜的，那就留在国内，毕竟国内机会比较多。但是如果你不属于这种，那么就想想你最在乎什么（ e.g.钱？健康？生活丰富度？稳定性？冒险刺激？相对公平的允许你靠自身努力上升的发展平台？）、如果去国外你是不是可以活得更开心（ e.g.哪些地方可以提供你在乎的这些东西）？</p>
<p>没有一个国家是完美的，日韩、欧洲、美国、新加坡都有各自的问题（日韩-经济并不是很好、并不是未来的主流市场、发展上限较低；欧洲-经济也不是特别好，除了德国英国稍微好点；美国-在太平洋两岸两位书记的联手协作下，民粹主义盛行；新加坡-主要产业为金融服务业，没有太多 tech 行业的机会）。如果你想追求刺激、追求暴富，那么可能中国更适合你。</p>
<p>但是国内也有国内的问题——e.g.摘取 11 例器官判 2 年 4 个月，写小黄书判 10 年半； 996 是常态；弱势群体随时有可能被“集体”绑架和以“维护集体利益”的名义牺牲。坦白说，中国虽然近年经济发展迅速，但是在对国民个体的保护上与西方国家还差着一整个“文艺复兴”（西方所有价值观的基础——“以人为本、破除神权”）。如果你觉得自己是一个弱势群体，那么可能中国对你来说就是 hard 模式。</p>
<p>最后，再次非常诚恳地建议很多和我一样的“弱势群体”，不要被别人割了韭菜，还帮着人家吆喝。保护好自己和家人、健康快乐地过好自己短暂的一生，这才是最重要的、这也是作为一个人的基本天性和权利—— [身为韭菜，不要自己给自己画饼] 。</p>
</blockquote>
<p><a href="https://www.v2ex.com/t/731552?p=2#r_9874150">Link</a> </p>
<blockquote>
<p>另外关于移民途径，似乎现在还是挺多的——人口减少是许多发达国家面临的巨大挑战，所以只要你年轻还是有很多机会的。全球发达国家中似乎只有美国是移民非常难的。</p>
<p>1 、加拿大——读书、拿工作签、枫叶卡；甚至如果不去加拿大读书和工作也可以直接申请枫叶卡，只要你打分足够——年纪轻加分、高学历加分、工作经验加分（自行搜索加拿大移民 Express Entry 打分系统）；<br>2 、新加坡——只要能找到工作就能申请到工作签和之后申请绿卡，没有名额限制。位于新加坡的 tech 公司虽然不多，但还是有几家，之前在 v 站也看到过相关的招人贴，请自行搜索；<br>3 、欧洲——只要能找到工作，就能申请到工作签并且之后申请绿卡，无名额限制。但是直接找欧洲工作比较难找，因为欧洲人自己找工作本身就比较难了（尤其是英国，暂且还是把英国算在欧洲吧 lol ）。加入国际公司再申请内部 relocation 的思路比较有实操意义，前提是你能说服老板为什么要 relocate 。要么就还是读书、工作签、申请绿卡，也不是很难。<br>4 、美国——除非能直接找到工作并且申请到 H1B，或者加入在华美国公司一年后以 L1 签证调来美国；要么就是读书、找工作、申请 H1B 、申请绿卡；要么就是投资移民、结婚移民等途径了。<br>5 、日韩——不清楚，按理说也不会很难。  </p>
<p>途径还是一直有的，就看你愿不愿意冒险和花成本了。经济上，我之前也见过许多国际学生贷款来读书的——可能国内觉得不可思议，但是美国挺常见的，如果你读 MBA 或者 JD 或者 STEM 这种未来赚钱能力强的学位，无需美国人担保即可贷款，请自行搜索 Prodigy Finance 。学校申请上，你如果是为了找工作，未必一定要申请顶尖名校，找工作够用就行。</p>
<p>所以，加油！</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Redis笔记01</title>
    <url>/2021/03/24/redis-note-01/</url>
    <content><![CDATA[<p>使用Redis时有时候会碰上一些并发的问题，这里来说一下分布式锁以及加锁超时等问题。</p>
<span id="more"></span>
<blockquote>
<p>封面<br>一天在某神社（？）看到的。非常向往这种中世纪风格，可能是因为《狼与香辛料》或者大多那种<br>剑与魔法的世界，都在这样的时代吧，让我觉得特别浪漫。</p>
</blockquote>
<h3 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h3><p>一般情况下，会对那些变化不大但是访问量比较大的请求做缓存处理，但缓存会在某个时刻失效，<br>此时就会有大量的请求涌向数据库从而容易引发雪崩效果。</p>
<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>为了避免雪崩，我们可以在更新缓存的代码块（即访问数据库）中加入分布式锁，只能够让一个线程去做缓存更新:</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">if</span> (redis.setIfAbsent(<span class="hljs-keyword">lock</span>, <span class="hljs-number">1</span>)) &#123; <br>    <span class="hljs-comment">// 更新缓存逻辑</span><br>    redis.del(<span class="hljs-keyword">lock</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是上面如果更新逻辑出现卡死现象就会造成死锁，所以我们还需要给锁设置超时时间，<br>但是设置超时时间一般的工具例如spring的RedisTemplate是没有把检查存在并设置值和设置超时时间<br>作为一个请求发送的，则无法保证是原子操作，这样也会发生在设置超时时间的时候没有成功导致死锁。  </p>
<p>由于redis新版本支持了setNX和EX复合指令的原子操作（即判断存在和设置超时时间），<br>所以我们可以去扩展RedisTemplate或者当前使用的工具类；另一种方法则是用lua脚本，执行lua脚本也是一次原子操作。</p>
<blockquote>
<p>redis在4.0之前整体都是单线程的，4.0后开始加入多线程，但也仅是部分操作，<br>所以就算非复合指令也可以通过一个请求发送多个指令的方式来达成原子操作的目的。</p>
</blockquote>
<figure class="highlight cos"><table><tr><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">if</span> (redis.setAndExpireIfAbsent(<span class="hljs-keyword">lock</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10000</span>)) &#123; <br>    <span class="hljs-comment">// 更新缓存逻辑</span><br>    redis.del(<span class="hljs-keyword">lock</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>redis 2.6.12 之前，set返回永远为ok，之后则设置成功时返回ok，<br>加入条件参数不成立则返回空</p>
</blockquote>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>但我们可能还会发现另一个问题，更新逻辑太久了超过了超时时间，此时锁已经被解除了，<br>这就会执行导致途中另一个线程获取到了锁，导致后面删除的时候是删除的另一个线程加的锁。  </p>
<p>所以我们需要引入一个随机id，作为当前线程加锁的标识，若后面发现不是相同id则不做删除。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">long</span> random = SnowFlakeGenerator.getInstant().nextId();<br><span class="hljs-keyword">if</span> (redis.setAndExpireIfAbsent(<span class="hljs-keyword">lock</span>, random, <span class="hljs-number">10000</span>)) &#123; <br>    <span class="hljs-comment">// 更新缓存逻辑</span><br>    <span class="hljs-keyword">if</span> (redis.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">lock</span>) == random) &#123;<br>        redis.del(<span class="hljs-keyword">lock</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Ok，到了这里你可能也发现了，这个删除是不是也要做原子操作比较好点(<br>没错…<br>若是不做原子操作，那可能就会虽然拿到锁的值能够匹配上，但是下一个瞬间就因为超时而被别的其他线程获取到锁<br>从而又引发了上面的问题，删错了别的线程的锁。</p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>类似的由于超时导致的问题还有一些情况就是计数器</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">synchronized (LOCK) &#123; <span class="hljs-comment">//只是为了排除多线程情况，这里只想讨论超时问题，实际情况还要具体分析</span><br>    <span class="hljs-keyword">if</span>(redis.exists(userId)) &#123;<br>        redis.incr();<br>        <span class="hljs-keyword">if</span> (redis.<span class="hljs-keyword">get</span>(userId) &gt; maxAllowedTimes) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        redis.<span class="hljs-keyword">set</span>(userId, <span class="hljs-number">1</span>);<br>        redis.setExpire(<span class="hljs-number">60000</span>);<br>        <span class="hljs-keyword">return</span> ture;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面是一段限制用户一分钟内可访问次数的redis计数器。<br>这里面如果判断到存在后的下一个瞬间恰好超时，此时incr方法在redis的行为就是先创建并设置值为0，然后加1，<br>而没有设置过期时间。导致后面永远被限制访问。  </p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">synchronized (LOCK) &#123;<br> <br>    <span class="hljs-keyword">if</span>(redis.<span class="hljs-keyword">exists</span>(userId)) &#123;<br>        <span class="hljs-built_in">long</span> <span class="hljs-keyword">count</span> = (<span class="hljs-built_in">long</span>) redis.incr(userId);<br>        <br>        <span class="hljs-keyword">if</span>(redis.ttl(userId) == <span class="hljs-number">-1</span>) &#123;<br>            redis.setExpire(<span class="hljs-number">60000</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> &gt; maxAllowedTimes) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        redis.setEx(userId, <span class="hljs-number">60000</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//设置1并设置超时时间60000</span><br>        <span class="hljs-keyword">return</span> ture;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>ttl<br>-2 表示key不存在<br>-1 表示key存在但是没有过期时间  </p>
</blockquote>
<p>另外一种解决办法就是取当前时间(或者是减去某个时间后)的秒数，然后再去除以60(时间周期)，<br>这样就能够获的一个周期数(第几个周期)，将其拼接在key上，则能够避免删错或者是没有设置超时时间的问题了。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">times</span> = time.<span class="hljs-keyword">times</span>()<span class="hljs-comment">//假设这是获取当前时间秒数的工具类</span><br>    <span class="hljs-comment">// COUNTER_INTERVAL 时间周期</span><br>    String key = <span class="hljs-string">&quot;ACCESS_COUNT:&quot;</span> + <span class="hljs-keyword">times</span>/COUNTER_INTERVAL + <span class="hljs-string">&quot;:&quot;</span> + userId <br>    <span class="hljs-keyword">if</span>(redis.exists(key)) &#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = (<span class="hljs-keyword">long</span>) redis.incr(key);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> &gt; maxAllowedTimes) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        redis.setEx(key, <span class="hljs-number">60000</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//设置1并设置超时时间60000</span><br>        <span class="hljs-keyword">return</span> ture;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title>Spring JPA 笔记 01</title>
    <url>/2024/08/03/spring-jpa-notes-01/</url>
    <content><![CDATA[<p>记录一下最近工作用jpa的一些心得，或者说就是坑（笑）</p>
<span id="more"></span>
<blockquote>
<p>Banner Illustration: <a href="https://www.pixiv.net/users/2131660">荻pote</a><br>非常通透的画面感，以及大多都是初/高中生。图里面一般都带有一定的叙事。但其实很多细节感觉还是不太好的，例如本图的衣服皱褶。但是个人风格非常明显，我还是很喜欢的。<br><a href="https://www.pixiv.net/artworks/86588827">https://www.pixiv.net/artworks/86588827</a></p>
</blockquote>
<hr>
<h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><p>众所周知，JPA Fetch Type 有 <code>Eager</code> 和 <code>Lazy</code>，而 <code>Eager</code> 只能有一个，那么其他就要在读取的时候（例如 <code>getter</code>）才会查库。这在某些量比较大的关联的表是不友好的，甚至有时候并不想查出来，这也困扰着我现在做的项目。</p>
<p>经过一番搜索，我看到大家都推荐用 <code>Entity Graph</code> 来解决这个问题，可是新的问题出现了，官方的 <code>Entity Graph</code> 是不支持动态传入的，所以我又找到了 <a href="https://github.com/Cosium/spring-data-jpa-entity-graph">spring-data-jpa-entity-graph</a> 这个项目，允许运行时传入 <code>Entity Graph</code>，所以这个问题也暂时告一段落了。</p>
<p>但是好景不长，由于项目本身是接手的以前的团队，另外实体类的关联规划也都早就写好了，不太可能改，而原想团队写这些实体类的时候几乎就是滥用的程度，想要查什么或者看起来就是能够关联上的就直接写进去，这让我们在开发报表类的需求时极其头疼，因为我们发现 <code>JPA</code>/<code>Hibernate</code> 就算你不去动那些懒加载的关联项，也会因为某种原因被触发，而且就我们项目来说几乎是 <code>Repository</code> 方法调用拿到结果赋值给一个对象的时候就发生了，再往里面跟踪我就实在是不太能够理解代码了，而且看起来几乎没有办法阻止。</p>
<p>所以我们就开始考虑直接用 <code>Entity Graph</code> 对那些懒加载（假如他会，因为不是所有懒加载都会去查询）的关联项都直接查询出来，毕竟比起懒加载一条一条查，一条 <code>sql</code> 查出来通常是更快的。<br>可是新的问题又出现了，因为其关联的对象巨大的，层层加码，导致一条 <code>sql</code> 关联的表实在是太多了（而且可能是重复关联）。  </p>
<p>几经周折，我们发现对于一些巨大的表来说，拆分查询，也就是查出来后把所有的 <code>id</code> 收集到后再去查库，会有更好的性能表现。但对于更加复杂的（我们报表开发几乎是基于存储过程再改写成 <code>java</code> 的）sql 就只能够用 native query（也就是直接写 sql）了。</p>
<blockquote>
<p>PS: 用 id 查询的时候有一个坑，就是巨大的 id 量也会导致其查询非常缓慢，所以有必要切分成几次查询，每次查2k左右</p>
</blockquote>
<h2 id="对象映射-空元素"><a href="#对象映射-空元素" class="headerlink" title="对象映射/空元素"></a>对象映射/空元素</h2><p>空元素出现实际上代表着该条目是有数据的，但是在 <code>JPA</code>/<code>Hibernate</code> 在进行对象映射的时候，由于该 <code>id</code> 为null，亦或者是这是一个组合 <code>id</code>，其中有一个字段是null的时候，就会发生。</p>
<p>虽然常用数据库可以写入条件限制这个情况的发生，但不幸的是我们现在用的数据库 <code>Sybase</code> 其实是没有主键的说法的，所以我们只是用 <code>index</code> 来做限制以达到类似主键的限制的目的。但是其不对该字段为空做限制，而且原先业务数据库所存在的数据就是这样，要么对数据库里的数据进行清洗，要么就是在代码层面兼容。</p>
<blockquote>
<p>PS: 这里面仍然有一个问题，实际上我们数据库是空白串，char固定长度类型，但是仍然在get值时返回给到null，这块还没有确定是不是单纯数据库驱动的问题。</p>
</blockquote>
<p>由于这些数据都是已经在用的了，做修改是非常大的风险， 而且也不单纯只是我们项目在用，除非客户本身已经考虑数据清洗/迁移了，所以数据清洗是不做考虑的。</p>
<p>所以我门最终是以修改 <code>JPA</code>/<code>Hibernate</code> 的数据映射达成的，就是对特定字段添加 mapper 注解调用自定义映射逻辑，把他改成空串。</p>
<p>重点在 <code>nullSafeGet</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NullToEmptyCharType</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserType</span> &#123;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sqlTypes() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;Types.VARCHAR&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; returnedClass() &#123;<br>        <span class="hljs-keyword">return</span> String.class;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object x, Object y)</span> <span class="hljs-keyword">throws</span> HibernateException &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span> &amp;&amp; y == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span> &amp;&amp; y != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> x == y || x.equals(y);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">(Object x)</span> <span class="hljs-keyword">throws</span> HibernateException &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(x);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">nullSafeGet</span><span class="hljs-params">(ResultSet rs, String[] names, SharedSessionContractImplementor session, Object owner)</span> <span class="hljs-keyword">throws</span> HibernateException, SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> rs.getString(names[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 就是这一步拿出的value就算数据库是空白串，这里的值也是null</span><br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> CommonUtil.EMPTY_STRING;<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nullSafeSet</span><span class="hljs-params">(PreparedStatement st, Object value, <span class="hljs-type">int</span> index, SharedSessionContractImplementor session)</span> <span class="hljs-keyword">throws</span> HibernateException, SQLException &#123;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            st.setNull(index, Types.VARCHAR);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> value.toString();<br>            st.setString(index, phone);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(Object value)</span> <span class="hljs-keyword">throws</span> HibernateException &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Whether the type is variable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMutable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is called when the type is written to the second-level cache</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Serializable <span class="hljs-title function_">disassemble</span><span class="hljs-params">(Object value)</span> <span class="hljs-keyword">throws</span> HibernateException &#123;<br>        <span class="hljs-keyword">return</span> (Serializable) value;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is called when data is fetched from the level 2 cache</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">assemble</span><span class="hljs-params">(Serializable cached, Object owner)</span> <span class="hljs-keyword">throws</span> HibernateException &#123;<br>        <span class="hljs-keyword">return</span> cached;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">replace</span><span class="hljs-params">(Object original, Object target, Object owner)</span> <span class="hljs-keyword">throws</span> HibernateException &#123;<br>        <span class="hljs-keyword">return</span> original;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Native-Query-with-Stream"><a href="#Native-Query-with-Stream" class="headerlink" title="Native Query with Stream"></a>Native Query with Stream</h2><p>由于上面说到过我们项目会写 <code>Dynamic SQL</code>，也就是会调用 <code>nativeQuery</code> 方法做查询，就碰上了奇怪的问题，这个我暂时没有搞明白是怎么回事。<br>简单说就是最后调用 <code>getResultStream</code> 获取结果的话，会导致异常的发生，说这个 <code>Stream</code> 已经执行过 <code>terminal</code> 操作，也就是执行了那些会触发 <code>Stream</code> 执行的方法。</p>
<p>Fix 也很简单，单纯就是不要用 <code>Stream</code> 接收他这个结果集，只用 List 操作。或者是用一个新的 List 接收再去做操作。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>ウマ娘手帳</title>
    <url>/2021/03/10/uma-musume-note/</url>
    <content><![CDATA[<p>记录一下玩马娘的心得(<del>已弃坑</del>)</p>
<span id="more"></span>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>在培训中，初期一般方针就是刷好感度，找人多的刷，属性一般也是水桶比较稳，直到出道战可能就会稍微改变一下。</p>
<ul>
<li>スタミナ(耐力)<br>首先属性里面耐力应该是比较关键的，如果耐力不足以跑完则会根据根性降低速度， 典型的就像<code>ダイワスカレと(大和红骥)</code>，<br>快到中期有一个2400m的中距离比赛，看攻略网站是要达到230才会比较安定，如果达不到基本就在最后被甩开了(btw，攻略提到有马的2500m要上到350才比较安定)<br>下面是一些估计值但跟上面看到的攻略不太一样<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">短距离   1200            200+<br>マイル   1400<span class="hljs-string">-1800</span>       250 ~ 300<br>中距离   2000<span class="hljs-string">-2400</span>       300 ~ 400<br>长距离   2500<span class="hljs-string">-3200</span><span class="hljs-string">-3600</span>  400 ~ 500+<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="固定技能升级"><a href="#固定技能升级" class="headerlink" title="固定技能升级"></a>固定技能升级</h3><ul>
<li>2月初是6W粉丝</li>
<li>4月初是7W粉丝+理事长好感3格</li>
<li>12月底是12W粉丝</li>
</ul>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>ウマ娘</tag>
      </tags>
  </entry>
  <entry>
    <title>鸣潮2.2 Gameplay</title>
    <url>/2025/03/29/wuthering-waves-2-2-gameplay/</url>
    <content><![CDATA[<p>突然入戏鸣潮2.2，就想写点东西释放一下心情(笑)</p>
<span id="more"></span>
<blockquote>
<p>Banner Illustration: 当然就是此次鸣潮的重点女角色卡缇西亚了  </p>
</blockquote>
<hr>
<h2 id="0x0"><a href="#0x0" class="headerlink" title="0x0"></a>0x0</h2><p>该游戏只是个二游，开发周期有限，加上看起来细节也完全不及其对手的绝区零好，我擅自认为是人力方面也不太足够，并且我不是很希望因为是个二游就降低我对一些审美感受上的预期与评价，但为了避免理解错位，我先说我对于此次故事整体的感受是非常ok的，以二游来讲，不然我也不会想写一篇文章。</p>
<h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>由于是新开的地图副本+没有什么人，所以本次故事看起来比较独立，涉及的主要人物也少，感觉算是比较能放开手脚的。 但本次其实是讲述了新地区——黎娜汐塔下的历史，是主线故事的背景设定，也不是说可以比较随意的写的。结合这两点加上绝区零这样的对手，我是觉得算是不那么畏手畏脚不愿意推进主线导致创作枯竭那一批，但我没看过明日方舟跟崩铁那块，不知道是不是其质量对比鸣潮好高一些。</p>
<h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>先说说让我感受比较好的  </p>
<p>本次某种程度来说也是一种命运之人打破命运的故事，基调是我喜欢的。坦白讲只是看故事本身不看整体游戏表现体验，明线上一点一点解开被歪曲的历史，一点一点构筑出这个地区的历史观，也一点一点揭开这个世界的一些秘密还是很爽的，埋下的伏笔也算回收的比较好，都是比较ok的。  </p>
<p>新地图其实在主线过程中没有那么多的奇观，因为大多都是在划船然后解密机关，这方面反倒是不如我自己在地图中探索了，这也多亏现在能飞所以地图设计的很开放，可以颠倒重力造成一些奇观以及整个地图都不算，也不会像1.0那样图是大但是也空旷。</p>
<p>故事叙事上或者说演出上前中期仍然是比较欠打磨，偶尔有一些过场是比较好看的，特别是由于鸣潮高质量的建模，360°几乎无死角，导致某几个桥段小卡的特写印象深刻，反倒是娇羞的那几段我只是觉得还行，偶尔也有一些地图上本身就是游戏高质量环境渲染加上简单的演出，气氛烘托应该是比较足够的，当然到没到位就不好说了，但整体来说是比较好的体验的，但故事本来就是更多的讲述历史，所以也不好说整个前中期主线走下来演出多好，起码我是有兴趣一直走完的。</p>
<p>后期解开故事的一些真相或者回收伏笔的时候，就有渐入佳境的感觉，直到进入boss战开场演出，其bgm专门为这几秒的人声配乐，再加上中途的bgm等是非常加分的，也是由于这些我就没去思考太多单纯享受演出给到的情感氛围。  </p>
<p>其中印象深刻的莫过于最后的剑气将大卡击飞出城堡的镜头随后立即拉近跟上并且剑已经刺穿，看几次都觉得好，紧接着又是BGM开始抓耳朵，后面救下小卡溅起水浪冲出去后立刻渐变至公主抱小卡到岸边也是感觉非常浪漫，丝毫不拖泥带水，不如说往前一点的战斗部分就其实挺好，这整一段播片应该都是比较优秀的。  </p>
<p>另一个是大卡开头的boss战开头本身其姿态就很好，再加上bgm到位，以及故事最后recall回这个开头都是非常惊喜的，就导致这个boss战开头印象深刻。<br>还有那三把剑砍下来每次都会切一次镜头感觉非常好。</p>
<p>这样想想，这次2.2的主线更多的还是由几个高质量部分以及一些叙事的伏笔（坎特蕾拉的二次共鸣真相，小卡的思念体真相）或是诡计（最后将boss战开场的镜头串起来）整体让我感到<br>不错，我也确实玩完后多次的去回味这些桥段久久没有平息。</p>
<h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p>其实看前面就知道，我对其也是因为有着部分的好桥段好演出盖过了大多缺点。</p>
<p>比如游戏的欠打磨感非常强，一些播片中途加载时居然有时候不是无缝的，一瞬间还看到原地站在刚刚的地方，再加上加载时还出bgm打破刚刚的氛围是很糟糕的一件事情。  </p>
<p>前中期除了一部分看起来比较用力的地方，大多时候动作也都不太行。举例马娘其实动作大多是那几个模板，但是足够生动以及会调整人物站位其站桩对话都是很有趣的。学园偶像表现力应该是更进一步，虽然这样要求鸣潮不公平，但是确实马娘就是体验好，就算不提马娘，最近的方舟终末地内测人物站桩对话也是很生动的。</p>
<p>另一方面，游戏中的细节不知道是因为最终调整后导致非常不通顺还是单纯工期赶都不太能表现出来，就是硬靠大家去推敲猜测。例如最后从小卡分离利维坦还是什么的到底细节是怎么样的？飞出去的球应该怎么理解？坎的二次共鸣力量是恰如其分的助大卡撕开结界让漂泊者到来还是一直让大卡撑到了这个时候？漂泊者使用权能是比较唐突的，大家应该都还没意识到这方面的作用以及漂泊者已经上手了。</p>
<h2 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h2><p>综上2.2剧情整体算是令人满意的了，但细究体验还是上上下下的，也就是说什么时候下的多一些或者上的不够多就可能不太行。不过我比较高兴的还是这个故事没有那么ML也好看，虽然有几个地方比较媚宅，但也就是一种感觉比较仰慕憧憬的感觉+为了媚宅让你有了错觉罢了。当然也不是说他们ML不好，守岸人这种甚至超越了一般的爱，后劲特别强，但我还是比较在意人物的独立性完整性吧，守岸人就挺好的，你要能再写个这样的我肯定很高兴。</p>
<p>我想大致就这些了。</p>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>Gameplay</tag>
        <tag>鸣潮</tag>
        <tag>Wuthering Waves</tag>
      </tags>
  </entry>
  <entry>
    <title>鸣潮2.6 Gameplay</title>
    <url>/2025/09/21/wuwa-2-6-gameplay/</url>
    <content><![CDATA[<p>世界末日了，你是希望神跟你说“别挣扎了，都是徒劳”，还是“挣扎一下，或许还有希望”？</p>
<span id="more"></span>
<hr>
<p>这个版本实际上没有对原本的主线做太多的推进，是克里斯托弗与利维坦给到的一些诡计尝试吞噬七丘，但本质上来说更多的是偏向角色的，是一个融入故事发展的角色故事。</p>
<h2 id="上半-奥古斯塔（日）"><a href="#上半-奥古斯塔（日）" class="headerlink" title="上半 - 奥古斯塔（日）"></a>上半 - 奥古斯塔（日）</h2><p>在上个版本末，有个神秘人跟我们讲述了一下以他视角下，或者说被他人传颂下的奥古斯塔的故事，还提到了英雄为什么是英雄，<br>但是这里的提问比较故作高深，因为2.6开始后上半讲述奥古斯塔里并没有那么的有深度，也符合奥古斯塔追求力量，用力量折服元老院，用力量碾压对于七丘的威胁。</p>
<p>故事是以日月蓄谋已久的计划开始——揪出神王（一种聚集了大量黑潮，残像能量的东西）并将其击溃。<br>但实际行动并不顺利，虽然能够逼出黑潮中的神王但初见没能够将其击溃，尤诺（月）也没有能够控制住神王，反而一度陷入了神王的吞噬中。<br>至此，被逼出的神王脱逃了，并反复吞噬着残像等以强大自身，而在月的预言中，这将是不久后七丘被黑潮吞没的开端。</p>
<p>在继续追踪神王的过程中，故事展示了七丘外围——奥古斯塔的故乡，昔日如何遇难于黑潮之下，同时也揭露了利维坦此刻也就已经盯上了奥古斯塔作为自己的棋子，<br>从中一直给予助力以及控制。<br>如之前圣女一般，利维坦企图通过人们的信仰以控制人们，所以奥古斯塔也就会被推向人们敬仰的英雄，与此同时迎来文明的覆灭。</p>
<p>终战前，奥古斯塔仍然开口问尤诺，既定的命运是否能够被改变，尤诺显得没有那么底气地肯定着是能够改变的，如此便拉开了序幕。<br>这段其实细究起来比较奇怪的但是放在后面再说。<br>在谁都没有发觉下，尤诺以自身为代价破除黑潮让神王现形，漂泊者和奥古斯塔来到了战场前，突然互斗了起来。<br>原来奥古斯塔计划是以一种符合预言的方式背叛预言——七丘的黑潮历代总是有英雄击退，此次原本推为英雄的奥古斯塔在这次战斗中败给漂泊者让漂泊者成为预言中的英雄。<br>这当然不是利维坦想见到的，故只能直接吞噬进黑潮后消磨意识殆尽后为自己所用，这当然也就正中计划的把心，从内部直接瓦解神王的力量。<br>最后，奥古斯塔借由历代被吞噬进黑潮人们的意志击溃神王。</p>
<h2 id="上半游玩感想"><a href="#上半游玩感想" class="headerlink" title="上半游玩感想"></a>上半游玩感想</h2><p>整体叙事都不拖沓，去掉了以前qte的比较僵硬没有太大自由的演出，取而代之的是一些场景的事件触发，体验非常好。  </p>
<p>与奥古斯塔打起来的过程中有无缝过场切入，那段也非常流畅。神王战斗过程中还会分阶段解放技能，bgm也随之做了配合，高潮部分演出也做了bgm的配合，一如既往的视听享受。  </p>
<p>其实这在2.2的过场动画高潮部分两人分开坠落部分的bgm就有配合演出了，只是当时没有那么明显，这次就是为了高潮段仅有的几秒钟，几个画面配合。</p>
<p>故事中奥古斯塔小时候的小镇也呈现了被黑潮所吞噬的景象，那段小镇地图不同时间互切也很有趣。</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV11BhDz7ErU?t=286.1&p=7">奥古斯塔战斗无缝cg</a>  </li>
<li><a href="https://www.bilibili.com/video/BV11BhDz7ErU?t=860.7&p=7">高潮部分bgm配合</a></li>
</ul>
<h2 id="下半-尤诺（月）"><a href="#下半-尤诺（月）" class="headerlink" title="下半 - 尤诺（月）"></a>下半 - 尤诺（月）</h2><p>下半是拯救月的故事。<br>月为锚定神王，由于力量差距太远最终只能够以自身的消失做为代价，陷入混沌中，一个存在与不存在的夹缝中。<br>为了救月，漂泊者需要进入混沌中为月拾取先前的记忆，巩固自我。  </p>
<p>通过记忆，玩家能够切身感受到预言中的命运如何的摆弄他人。<br>虽然你知道将来会怎么样，但是你并不知道到达那时的路途会是如何，很可能是以一种人们都不希望遇见的情况来临。<br>你知道了将来注定这条路是不幸的，那继续走这条路的意义是什么？<br>这就像是月预知七丘的未来，但是七丘总是陷入毁灭，所以最后她放弃了谕女预知的能力，从而换来了锚定黑潮的能力， 与此同时武器成了她心中的支柱，<br>一个有能力对抗黑潮的武器。</p>
<p>漂泊者在最后就是交付于尤诺武器后让尤诺重拾了自己当初的决断，打破命运的桎梏，最终重返世界当中。</p>
<h2 id="下半游玩感想"><a href="#下半游玩感想" class="headerlink" title="下半游玩感想"></a>下半游玩感想</h2><p>下半的故事由于参杂入主线的内容更少了，所以显得比较简单，主题就是怎么面对命运，游戏中体验预知命运的那段我印象比较深刻，那三段预言其实算是比较常见的套路，<br>但是我当时会陷入一个应该如何对待这个世界的所谓的命运，换句话说，知道自己最终走向破灭是非常让人无助的。<br>除此之外，故事进入最终战斗时穿插了一段战斗&gt;过场&gt;战斗&gt;过场，虽然不是奥古斯塔那样无缝，但是转场非常自然，过场黑屏切入战斗时已经是一个技能动作，而且由于尤诺切换新月，弦月的动作演出非常好看，<br>也就造就了这几段互相转场的自然感，而且此时的音乐其实是没有停止的，是一直延续着下去，这种精心编排的演出在视听上体验非常好。</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1xMptzcE3F?t=1&p=6">最终战的几段过场于战斗穿插</a></li>
</ul>
<h2 id="总体感想"><a href="#总体感想" class="headerlink" title="总体感想"></a>总体感想</h2><p>一如既往的视听享受，能够感受到比较突出的就是音乐和画面演出的精心编排，情感调动也是一如既往的好。  </p>
<p>但这不像是2.2卡提希娅那样，卡提希娅是主线中的关键人物，也是她的故事推进主线发展。2.6日月的故事更加偏向于角色，这看起来是商业上的妥协，而这次我也没有什么反感之处，<br>只是警觉到，往后还是这样主线是否还能得到适当的发展，会不会被主推卡池中的人物所过度牵连。</p>
<p>另外还想提一下，月的技能中切换新月，弦月非常有意思，往下穿越后来到空中，往上穿越后来到地面，整体动画演出非常的流畅以至觉得能够媲美过场动画演出。</p>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>Gameplay</tag>
        <tag>鸣潮</tag>
        <tag>Wuthering Waves</tag>
      </tags>
  </entry>
  <entry>
    <title>とある三秋 缒の摘抄</title>
    <url>/2017/05/20/%E3%81%A8%E3%81%82%E3%82%8B%E4%B8%89%E7%A7%8B%20%E7%BC%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<p>记录一下比较打动我的一些段落</p>
<span id="more"></span>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><p>&emsp;&emsp;这世上到处都有地洞，至少世界看在我眼里就是这样。有的洞小，有的洞大；有的洞浅，有的洞深；有的洞很明显，有的洞不明显；有的洞尚有人掉进去，有的洞已经有许多人掉进去。真的是五花八门。一旦想着这一个个地洞，就会让我满心不安，一步都不想动了。<br>&emsp;&emsp;孩提时代，我喜欢那种会让我忘记地洞存在的故事。看来不只是我，大家都喜欢看那种书中世界的所有地洞都已经加盖的故事，也不知道是不是该叫“杀菌过的故事”。当然主角不会只遇到好事，经历的各种痛苦与难受的体验也不会比别人少，但最终来说，这一切都将成为他成长的动力，让读者可以沉浸在“人就是要接受一切勇敢活下去”这种可靠的感觉中。我说的就是这种故事。<br>&emsp;&emsp;我想我们一定是不希望连在虚构的世界都要经历悲伤<br>&emsp;&emsp;可是有一天，我发现自己不知不觉地身在阴暗的地洞中。那是一种没有任何前兆、没有天理可言的失足。由于那是个非常小且不起眼的地洞，很难指望会有别人帮助。所幸这个地洞并不是深到爬不出来，我花了很长时间，靠自己的力量终于脱身。<br>&emsp;&emsp;来到地上后，我沐浴在久违的温暖阳光与清澈的徐风中，因而产生这样的想法。无论多么小心，都没有人知道何时会掉进地洞。这个世界就是这样的地方。下次我说不定会掉进一个更深的洞，深得让我再也回不到地面上。到时候，我该怎么办呢？<br>&emsp;&emsp;从此之后，我就再也无法怀着以往那样单纯的心情，去看待那些“把地洞加了盖的故事”。相对地，我开始喜欢描写“在地洞里过的好像很幸福的人”的故事。因为我想听的是在阴暗、深邃、狭窄又寒冷的地洞里，不用逞强也能露出微笑的人身上所发生的故事。也许对现在的我来说，再也没有什么比这个更能安慰我了。</p>
<footer><strong>三秋 缒</strong><cite>いたいのいたいの、とんでゆけ</cite></footer></blockquote>
]]></content>
      <tags>
        <tag>三秋 缒</tag>
        <tag>摘抄</tag>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title>将项目部署在docker中</title>
    <url>/2019/03/14/%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8docker%E4%B8%AD/</url>
    <content><![CDATA[<p>docker中有两个概念，容器与镜像。 </p>
<p>镜像我们可以简单的理解为是装机用的光盘，而容器就是我们用光盘所装的一个系统。实际上我们就是由镜像生成一个容器，一个镜像可以生成多个容器（只要容器互不相冲突）。</p>
<p>而镜像的生成就是由配置文件来决定（配置文件参数可由后期运行指令等等操作更改），具体如何配置不详细说明。</p>
<span id="more"></span>
<blockquote>
<p>Banner: <a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=47646872" title="カントク - COLORS" target>カントク - COLORS</a></p>
</blockquote>
<p>配置文件例子<br>Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#后端java项目</span><br><br><span class="hljs-comment">#基础镜像</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">1.2</span>:<span class="hljs-number">5000</span>/library/centos-jdk:<span class="hljs-number">1.7</span>.<span class="hljs-number">79</span><br><span class="hljs-comment">#作者</span><br><span class="hljs-keyword">MAINTAINER</span> kurenai kurenai@moe.com<br><span class="hljs-comment">#执行命令，主要用来安装相关的软件</span><br><span class="hljs-comment">#RUN </span><br><span class="hljs-comment">#添加文件</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> target/supervise-svc-0.0.1-SNAPSHOT.jar /usr/local</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> u+x /usr/local/supervise-svc-0.0.1-SNAPSHOT.jar</span><br><span class="hljs-comment">#挂载目录到容器</span><br><span class="hljs-comment">#VOLUME [&quot;/data&quot;]</span><br><span class="hljs-comment">#环境变量设置</span><br><span class="hljs-comment">#ENV </span><br><span class="hljs-comment">#开放端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">1234</span><br><span class="hljs-comment">#启动时执行的命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>]</span><br><span class="hljs-comment">#启动时执行的命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;-Xms2048m&quot;</span>, <span class="hljs-string">&quot;-Xmx2048m&quot;</span>, <span class="hljs-string">&quot;-XX:PermSize=256M&quot;</span>, <span class="hljs-string">&quot;-XX:MaxPermSize=256M&quot;</span>,<span class="hljs-string">&quot;/usr/local/supervise-svc-0.0.1-SNAPSHOT.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#前端react项目</span><br><br><span class="hljs-comment">#基础镜像</span><br><span class="hljs-keyword">FROM</span> xxx.xxx.com:<span class="hljs-number">5000</span>/library/ui-nginx:latest<br><br><span class="hljs-comment">#维护人信息</span><br><span class="hljs-keyword">MAINTAINER</span> kurenai kurenai@moe.com<br><br><span class="hljs-comment">#工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/local/nginx</span><br><br><span class="hljs-keyword">ADD</span><span class="language-bash"> ui.tar.gz /usr/local/nginx/html/</span><br><br><span class="hljs-keyword">ADD</span><span class="language-bash"> nginx.conf /usr/local/nginx/conf/</span><br><br><span class="hljs-comment">#暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><br><span class="hljs-comment">#连接时执行的命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>]</span><br><br><span class="hljs-comment">#启动时执行的命令</span><br><span class="hljs-comment">#ENTRYPOINT nginx -g &quot;daemon off;&quot;</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> /opt/run.sh</span><br></code></pre></td></tr></table></figure>
<ul>
<li>基础命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker ps       <span class="hljs-comment">#查看doker中正在运行的容器列表</span><br>docker images   <span class="hljs-comment">#查看docker中的镜像列表</span><br>docker build    <span class="hljs-comment">#将当前目录下的文件打包为镜像</span><br>docker <span class="hljs-built_in">rm</span>       <span class="hljs-comment">#移除容器</span><br>docker rmi      <span class="hljs-comment">#移除镜像</span><br>docker pull     <span class="hljs-comment">#拉取镜像</span><br>docker logs -f  <span class="hljs-comment">#查看日志</span><br>docker restart  <span class="hljs-comment">#重启容器</span><br>docker stop     <span class="hljs-comment">#停止容器运行</span><br></code></pre></td></tr></table></figure>

<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>能够比较集中的管理镜像和容器的部署问题，不必用像原生docker那样一个一个项目进行打包镜像生成容器，只需要把n个项目的配置写在配置文件中即可进行批量打包，拉取镜像，生成容器</p>
<p>配置文件例子<br>docker-compose.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2.2&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-comment">#项目名称，用docker-compose做管理时，每个项目用这里配置的名称进行单独管理</span><br>  <span class="hljs-attr">base:</span><br>    <span class="hljs-comment">#镜像名，拉取镜像时也是用这个名字作为地址</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span><span class="hljs-string">:5000/test/base-svc:0.0.1-SNAPSHOT</span> <br>    <span class="hljs-comment">#打包路径，即docker build的路径</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">/opt/dockerfile/base-svc</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-comment">#环境变量</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://192.168.1.3:1200/eureka/</span><br>    <span class="hljs-comment">#开放端口</span><br>    <span class="hljs-attr">ports:</span> <br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;1430:1430&quot;</span><br>    <span class="hljs-comment">#网络连接模式</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">&quot;bridge&quot;</span><br><br>  <span class="hljs-attr">supervise:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span><span class="hljs-string">:5000/test/supervise-svc:0.0.1-SNAPSHOT</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">/opt/dockerfile/supervise-svc</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://192.168.1.3:1200/eureka/</span><br>    <span class="hljs-attr">ports:</span> <br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;1570:1570&quot;</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">&quot;bridge&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>常用命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker-copmpose build       <span class="hljs-comment">#打包镜像，后面不加项目名则打包所有配置了build的项目，可接多个项目名，用空格隔开</span><br>docker-compose up -d        <span class="hljs-comment">#后台运行项目，寻找本地镜像生成容器（若镜像更新则重启用新镜像生成容器），或者docker-compose.yml文件改变了也会进行更新容器，同样不接项目名为所有项目，也可以接多个项目名</span><br>docker-compose logs -f      <span class="hljs-comment">#查看日志，同上可接项目名</span><br>docker-compose pull         <span class="hljs-comment">#拉取镜像，同上可接项目名</span><br>docker-compose restart      <span class="hljs-comment">#重启容器，同上</span><br>docker-compose stop         <span class="hljs-comment">#停止运行容器，同上</span><br></code></pre></td></tr></table></figure>

<h2 id="实际生产环境部署项目"><a href="#实际生产环境部署项目" class="headerlink" title="实际生产环境部署项目"></a>实际生产环境部署项目</h2><p><code>/opt/dockerfile</code>文件夹下是每个项目的目录，每个目录下是一个Dockerfile配置文件+打包的项目文件（java为.jar, react为tar.gz, 视项目和配置文件而定）</p>
<p><code>/opt/cloud</code>目录下是分的几个类，把几个项目归为一起，项目下是docker-compose.yml配置文件</p>
<p>以后端java项目<code>meeting-svc</code>为例 </p>
<ol>
<li>打包项目为jar包，</li>
<li>将jar包放在<code>/opt/dockerfile/meeting-svc</code>目录下</li>
<li>进入到<code>/opt/cloud/service</code></li>
<li>运行指令<code>docker-compose build meeting</code>(配置文件中配置的项目名为<code>meeting</code>)打包镜像</li>
<li>运行<code>docker-compose up -d meeting</code>更新容器并运行</li>
<li>用<code>docker-compose logs -f meeting</code>进行查看日志</li>
</ol>
<hr>
<p>ps： 后端打包为tar -zcvf xxx.tar.gz -C dist/ .      #dist为编译文件目录</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>ops</tag>
      </tags>
  </entry>
</search>
