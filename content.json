{"meta":{"title":"Kurenai's Blog","subtitle":"Welcome To My Kingdom","description":"君を見てると、心が震える","author":"Kurenai","url":"https://blog.kurenai.moe","root":"/"},"pages":[{"title":"","date":"2025-09-20T21:44:50.603Z","updated":"2021-08-25T02:47:25.000Z","comments":false,"path":"googlef50674fb2852e90b.html","permalink":"https://blog.kurenai.moe/googlef50674fb2852e90b.html","excerpt":"","text":"google-site-verification: googlef50674fb2852e90b.html"},{"title":"about","date":"2020-07-06T17:40:18.000Z","updated":"2022-02-28T14:20:58.000Z","comments":false,"path":"about/index.html","permalink":"https://blog.kurenai.moe/about/index.html","excerpt":"","text":"I’m a/an … Windows user Android user Office worker ACGN lover Java programmer I’m currently learning … Japanese Netty Everything PGPPrimary UID: Kurenai &lt;&#107;&#117;&#114;&#101;&#x6e;&#97;&#x69;&#50;&#51;&#51;&#64;&#x79;&#97;&#104;&#111;&#111;&#x2e;&#x63;&#x6f;&#109;&gt;Fingerprint: DC5E 371D 93BE DB5D CA96 0AB6 98FA 0519 E92E D1B9"},{"title":"categories","date":"2017-02-25T21:18:30.000Z","updated":"2017-02-25T17:11:41.000Z","comments":false,"path":"categories/index.html","permalink":"https://blog.kurenai.moe/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-02-25T20:45:46.000Z","updated":"2017-02-25T17:11:41.000Z","comments":false,"path":"tags/index.html","permalink":"https://blog.kurenai.moe/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基于 JPA 的多租户实现后续","slug":"JPA-based-multi-tenancy-impl-issues","date":"2025-09-21T09:22:00.000Z","updated":"2025-09-20T21:44:32.000Z","comments":true,"path":"2025/09/21/JPA-based-multi-tenancy-impl-issues/","permalink":"https://blog.kurenai.moe/2025/09/21/JPA-based-multi-tenancy-impl-issues/","excerpt":"经过一段时间后，上次构思的实现发现了一些问题","text":"经过一段时间后，上次构思的实现发现了一些问题 数据库链接的默认值由于数据库初始化的时候必须给到一个初始配置（X 类型，Y cluster），这个没有太大问题，但是切换数据库的时候需要严谨的判断，判断目标数据库是否已配置，判断目标数据库是否在在active list中，避免拿到一个default的数据库链接。 数据ID的生成ID如果是用table generator并且预取N&gt;1的id会导致切换数据库后拿的是上一个数据库的id插入，解决办法要么是预取size设置为1，要么改造默认的生成器以适配数据库切换。 改在默认生成器会比较麻烦，原本的实现写了比较多的情况以及方法的抽象。 待续","categories":[{"name":"编程","slug":"编程","permalink":"https://blog.kurenai.moe/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://blog.kurenai.moe/tags/JPA/"}]},{"title":"鸣潮2.6 Gameplay","slug":"wuwa-2-6-gameplay","date":"2025-09-21T02:48:00.000Z","updated":"2025-09-20T21:44:22.000Z","comments":true,"path":"2025/09/21/wuwa-2-6-gameplay/","permalink":"https://blog.kurenai.moe/2025/09/21/wuwa-2-6-gameplay/","excerpt":"世界末日了，你是希望神跟你说“别挣扎了，都是徒劳”，还是“挣扎一下，或许还有希望”？","text":"世界末日了，你是希望神跟你说“别挣扎了，都是徒劳”，还是“挣扎一下，或许还有希望”？ 这个版本实际上没有对原本的主线做太多的推进，是克里斯托弗与利维坦给到的一些诡计尝试吞噬七丘，但本质上来说更多的是偏向角色的，是一个融入故事发展的角色故事。 上半 - 奥古斯塔（日）在上个版本末，有个神秘人跟我们讲述了一下以他视角下，或者说被他人传颂下的奥古斯塔的故事，还提到了英雄为什么是英雄，但是这里的提问比较故作高深，因为2.6开始后上半讲述奥古斯塔里并没有那么的有深度，也符合奥古斯塔追求力量，用力量折服元老院，用力量碾压对于七丘的威胁。 故事是以日月蓄谋已久的计划开始——揪出神王（一种聚集了大量黑潮，残像能量的东西）并将其击溃。但实际行动并不顺利，虽然能够逼出黑潮中的神王但初见没能够将其击溃，尤诺（月）也没有能够控制住神王，反而一度陷入了神王的吞噬中。至此，被逼出的神王脱逃了，并反复吞噬着残像等以强大自身，而在月的预言中，这将是不久后七丘被黑潮吞没的开端。 在继续追踪神王的过程中，故事展示了七丘外围——奥古斯塔的故乡，昔日如何遇难于黑潮之下，同时也揭露了利维坦此刻也就已经盯上了奥古斯塔作为自己的棋子，从中一直给予助力以及控制。如之前圣女一般，利维坦企图通过人们的信仰以控制人们，所以奥古斯塔也就会被推向人们敬仰的英雄，与此同时迎来文明的覆灭。 终战前，奥古斯塔仍然开口问尤诺，既定的命运是否能够被改变，尤诺显得没有那么底气地肯定着是能够改变的，如此便拉开了序幕。这段其实细究起来比较奇怪的但是放在后面再说。在谁都没有发觉下，尤诺以自身为代价破除黑潮让神王现形，漂泊者和奥古斯塔来到了战场前，突然互斗了起来。原来奥古斯塔计划是以一种符合预言的方式背叛预言——七丘的黑潮历代总是有英雄击退，此次原本推为英雄的奥古斯塔在这次战斗中败给漂泊者让漂泊者成为预言中的英雄。这当然不是利维坦想见到的，故只能直接吞噬进黑潮后消磨意识殆尽后为自己所用，这当然也就正中计划的把心，从内部直接瓦解神王的力量。最后，奥古斯塔借由历代被吞噬进黑潮人们的意志击溃神王。 上半游玩感想整体叙事都不拖沓，去掉了以前qte的比较僵硬没有太大自由的演出，取而代之的是一些场景的事件触发，体验非常好。 与奥古斯塔打起来的过程中有无缝过场切入，那段也非常流畅。神王战斗过程中还会分阶段解放技能，bgm也随之做了配合，高潮部分演出也做了bgm的配合，一如既往的视听享受。 其实这在2.2的过场动画高潮部分两人分开坠落部分的bgm就有配合演出了，只是当时没有那么明显，这次就是为了高潮段仅有的几秒钟，几个画面配合。 故事中奥古斯塔小时候的小镇也呈现了被黑潮所吞噬的景象，那段小镇地图不同时间互切也很有趣。 奥古斯塔战斗无缝cg 高潮部分bgm配合 下半 - 尤诺（月）下半是拯救月的故事。月为锚定神王，由于力量差距太远最终只能够以自身的消失做为代价，陷入混沌中，一个存在与不存在的夹缝中。为了救月，漂泊者需要进入混沌中为月拾取先前的记忆，巩固自我。 通过记忆，玩家能够切身感受到预言中的命运如何的摆弄他人。虽然你知道将来会怎么样，但是你并不知道到达那时的路途会是如何，很可能是以一种人们都不希望遇见的情况来临。你知道了将来注定这条路是不幸的，那继续走这条路的意义是什么？这就像是月预知七丘的未来，但是七丘总是陷入毁灭，所以最后她放弃了谕女预知的能力，从而换来了锚定黑潮的能力， 与此同时武器成了她心中的支柱，一个有能力对抗黑潮的武器。 漂泊者在最后就是交付于尤诺武器后让尤诺重拾了自己当初的决断，打破命运的桎梏，最终重返世界当中。 下半游玩感想下半的故事由于参杂入主线的内容更少了，所以显得比较简单，主题就是怎么面对命运，游戏中体验预知命运的那段我印象比较深刻，那三段预言其实算是比较常见的套路，但是我当时会陷入一个应该如何对待这个世界的所谓的命运，换句话说，知道自己最终走向破灭是非常让人无助的。除此之外，故事进入最终战斗时穿插了一段战斗&gt;过场&gt;战斗&gt;过场，虽然不是奥古斯塔那样无缝，但是转场非常自然，过场黑屏切入战斗时已经是一个技能动作，而且由于尤诺切换新月，弦月的动作演出非常好看，也就造就了这几段互相转场的自然感，而且此时的音乐其实是没有停止的，是一直延续着下去，这种精心编排的演出在视听上体验非常好。 最终战的几段过场于战斗穿插 总体感想一如既往的视听享受，能够感受到比较突出的就是音乐和画面演出的精心编排，情感调动也是一如既往的好。 但这不像是2.2卡提希娅那样，卡提希娅是主线中的关键人物，也是她的故事推进主线发展。2.6日月的故事更加偏向于角色，这看起来是商业上的妥协，而这次我也没有什么反感之处，只是警觉到，往后还是这样主线是否还能得到适当的发展，会不会被主推卡池中的人物所过度牵连。 另外还想提一下，月的技能中切换新月，弦月非常有意思，往下穿越后来到空中，往上穿越后来到地面，整体动画演出非常的流畅以至觉得能够媲美过场动画演出。","categories":[{"name":"Game","slug":"Game","permalink":"https://blog.kurenai.moe/categories/Game/"}],"tags":[{"name":"Gameplay","slug":"Gameplay","permalink":"https://blog.kurenai.moe/tags/Gameplay/"},{"name":"鸣潮","slug":"鸣潮","permalink":"https://blog.kurenai.moe/tags/%E9%B8%A3%E6%BD%AE/"},{"name":"Wuthering Waves","slug":"Wuthering-Waves","permalink":"https://blog.kurenai.moe/tags/Wuthering-Waves/"}]},{"title":"基于 JPA 的多租户实现","slug":"JPA-based-multi-tenancy-implementation","date":"2025-06-04T16:39:44.000Z","updated":"2025-09-20T21:44:22.000Z","comments":true,"path":"2025/06/04/JPA-based-multi-tenancy-implementation/","permalink":"https://blog.kurenai.moe/2025/06/04/JPA-based-multi-tenancy-implementation/","excerpt":"在工作开发中我遇到了需要链接多个DB项目的情况，业务上以不同的医院进行请求查询，而一个cluster能够包含几个医院，一个cluster则会划分到一个DB（或schema）中，基本上可以认为不同cluster为不同的db connection，至此该项目就像是多租户上划分多个db的情况了。","text":"在工作开发中我遇到了需要链接多个DB项目的情况，业务上以不同的医院进行请求查询，而一个cluster能够包含几个医院，一个cluster则会划分到一个DB（或schema）中，基本上可以认为不同cluster为不同的db connection，至此该项目就像是多租户上划分多个db的情况了。 Requirement Thread-Safe基于servlet一个请求绑定一个线程 根据请求切换至对应数据库 链接多于一种类型数据库由于业务还需要逐步从A数据库到B数据库，这期间一定会有链接两种数据库的情况 监听/定时刷新激活的数据库配置即哪些cluster已转移至B数据库，哪些没有 Thinking由于传统Servlet为一个请求绑定住一个线程，除非自己切换不然都能够安全通过ThreadLocl来作为上下文确定当前应该切换至哪个cluster。但需要注意，每个请求过来绑定的线程不一定会在请求结束后销毁，也许会被重复利用在下一个请求当中，所以需要加入一个OnePerRequestFilter在请求结束后清空ThreadLocal上下文已保证新请求绑定已有线程不被污染。Btw，Reactive就要用Reactive的线程上下文了。 激活的数据库配置初步是定为配置文件放在minio中共各个服务读取，以达成统一配置减少线上部署人员的工作，定时刷则用timer定时跑一个task重复刷新配置文件，这里需要给到相关变量读写锁的控制，另外在初始化timer的时候要用双检锁保证exactly-once initialize(瞎掰的词，源自exactly-once delivery)。 而链接不同数据库，在同一种数据库下是可以直接用AbstractRoutingDataSource做动态切换的，但你需要在事务开启前做这个事情，另外还需要注意，spring.jpa.open-in-view需要关闭它以避免请求过来的时候就过早开启一个session导致各种问题的发生，参考这里。但需求是链接两种数据库，那么你还需要对Entity Manager做Routing来确保两种不同的数据库方言能够正运行。所以下面就开始了部分源码的阅读以及调试时实际情况是如何的了。 Learning &amp; Debug实际上，如果不希望冒着这样的风险做改动，最简单的做法就是将配置复制N分，遇到什么cluster就用什么repository，但是我们有7个cluster x 2种数据库，感觉还是太蠢了。那么动态生成repository呢？我想应该是可以的，但他需要一个entitymanger，那你是不是又要自己动态生成一个entitymanager呢？然后一系列的东西就会指引到TransactionMnager上。 经过断点，DataSource#getConnection以及EntityManagerFactory#createEntityManager，然后你就会发现在一个Transaction内他们是只会调用一次的，而调用的地方就是JpaTransactionManager#doBegin，也就是进入被@Transactional注解的方法前，而在前面两个方法创建后，EntityManager会放入这次Transaction的上下文对象JpaTransactionObject(该对象在doGetTransaction方法生成)的EntityManagerHolder中，并且绑定到TransactionSynchronizationManager，DataSource则只会绑定至TransactionSynchronizationManager。也就是说，spring事务开启后，处于事务期间你是无法切换EntityMnager以及DataSource的，除非你自定义一个TransactionMnager，但是如果我们自定义事务管理器可以拿两个EntityManagerFactory，但是Repository的配置中只会认一个EntityManagerFactory，所以最终你还是必须有一个Routing的EntityManagerFactory。 之后根据源码可以了解到实际上事务管理器没有用到太多EntityManagerFactory的接口，我们只需要重写AbstractEntityManagerFactoryBean下的createNativeEntityManagerFactory, getNativeEntityManagerFactory，这些方法都根据当前上下文的cluster以及迁移的db类型配置路由到对应的FactoryBean上就好了，一般直接拿nativeEntityManagerFactory就好了，destroy方法直接调用一边维护的所有FactoryBean就好了。 为什么是FactoryBean？因为这是特殊的类型，实际注入的是getObject拿到的对象，而AbstractEntityManagerFactoryBean的对象则会维护在nativeEntityManagerFactory变量上。 这样我们也就可以用一个repository实现需求了。 但是且慢，我们知道事务注解下的情况，那非事务下呢？实际上这个也是最开始我有做断点了解到的，非事务下是会有一个shared相关的实例（具体忘了是啥了），他会绑定到Primary的DataSource, EntityManagerFactory，所以这也是为什么思考方向会朝着一个单独的一个配置做Routing去。Btw，务必保证有一个主要的一套配置在，不然JPA Auto Configuration不会生效。 至此我们就能够实现之前提出要求了。 Implement只重点说一下Jpa的配置，首先需要两套DataSource，EntityManagerFactory，分别为A数据库类型和B数据库类型，而DataSource是一个Routing到同类型不同数据库的数据源，再加入一个主要数据源Routing不同数据库类型到实际的Routing数据源，一个主要EntityManagerFactory并自定义实现的Routing功能就好了。融合一个大的主要数据源还有个原因是为了可以用JdbcTemplate ConclusionDemo可以在这里看到，并且这是非常实验性的，还未跑过大量数据以及业务去验证其正确性，例如多个不同传播类型的事务互相调用互相嵌套的情况。另外AbstractEntityManagerFactoryBean也不是很能够确定是否这样重写几个接口就没有问题，只是目前发现TransactionManager没有过多使用其他接口。","categories":[{"name":"编程","slug":"编程","permalink":"https://blog.kurenai.moe/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://blog.kurenai.moe/tags/JPA/"}]},{"title":"鸣潮2.2 Gameplay","slug":"wuthering-waves-2-2-gameplay","date":"2025-03-29T02:48:00.000Z","updated":"2025-09-20T21:44:22.000Z","comments":true,"path":"2025/03/29/wuthering-waves-2-2-gameplay/","permalink":"https://blog.kurenai.moe/2025/03/29/wuthering-waves-2-2-gameplay/","excerpt":"突然入戏鸣潮2.2，就想写点东西释放一下心情(笑)","text":"突然入戏鸣潮2.2，就想写点东西释放一下心情(笑) Banner Illustration: 当然就是此次鸣潮的重点女角色卡缇西亚了 0x0该游戏只是个二游，开发周期有限，加上看起来细节也完全不及其对手的绝区零好，我擅自认为是人力方面也不太足够，并且我不是很希望因为是个二游就降低我对一些审美感受上的预期与评价，但为了避免理解错位，我先说我对于此次故事整体的感受是非常ok的，以二游来讲，不然我也不会想写一篇文章。 0x1由于是新开的地图副本+没有什么人，所以本次故事看起来比较独立，涉及的主要人物也少，感觉算是比较能放开手脚的。 但本次其实是讲述了新地区——黎娜汐塔下的历史，是主线故事的背景设定，也不是说可以比较随意的写的。结合这两点加上绝区零这样的对手，我是觉得算是不那么畏手畏脚不愿意推进主线导致创作枯竭那一批，但我没看过明日方舟跟崩铁那块，不知道是不是其质量对比鸣潮好高一些。 0x2先说说让我感受比较好的 本次某种程度来说也是一种命运之人打破命运的故事，基调是我喜欢的。坦白讲只是看故事本身不看整体游戏表现体验，明线上一点一点解开被歪曲的历史，一点一点构筑出这个地区的历史观，也一点一点揭开这个世界的一些秘密还是很爽的，埋下的伏笔也算回收的比较好，都是比较ok的。 新地图其实在主线过程中没有那么多的奇观，因为大多都是在划船然后解密机关，这方面反倒是不如我自己在地图中探索了，这也多亏现在能飞所以地图设计的很开放，可以颠倒重力造成一些奇观以及整个地图都不算，也不会像1.0那样图是大但是也空旷。 故事叙事上或者说演出上前中期仍然是比较欠打磨，偶尔有一些过场是比较好看的，特别是由于鸣潮高质量的建模，360°几乎无死角，导致某几个桥段小卡的特写印象深刻，反倒是娇羞的那几段我只是觉得还行，偶尔也有一些地图上本身就是游戏高质量环境渲染加上简单的演出，气氛烘托应该是比较足够的，当然到没到位就不好说了，但整体来说是比较好的体验的，但故事本来就是更多的讲述历史，所以也不好说整个前中期主线走下来演出多好，起码我是有兴趣一直走完的。 后期解开故事的一些真相或者回收伏笔的时候，就有渐入佳境的感觉，直到进入boss战开场演出，其bgm专门为这几秒的人声配乐，再加上中途的bgm等是非常加分的，也是由于这些我就没去思考太多单纯享受演出给到的情感氛围。 其中印象深刻的莫过于最后的剑气将大卡击飞出城堡的镜头随后立即拉近跟上并且剑已经刺穿，看几次都觉得好，紧接着又是BGM开始抓耳朵，后面救下小卡溅起水浪冲出去后立刻渐变至公主抱小卡到岸边也是感觉非常浪漫，丝毫不拖泥带水，不如说往前一点的战斗部分就其实挺好，这整一段播片应该都是比较优秀的。 另一个是大卡开头的boss战开头本身其姿态就很好，再加上bgm到位，以及故事最后recall回这个开头都是非常惊喜的，就导致这个boss战开头印象深刻。还有那三把剑砍下来每次都会切一次镜头感觉非常好。 这样想想，这次2.2的主线更多的还是由几个高质量部分以及一些叙事的伏笔（坎特蕾拉的二次共鸣真相，小卡的思念体真相）或是诡计（最后将boss战开场的镜头串起来）整体让我感到不错，我也确实玩完后多次的去回味这些桥段久久没有平息。 0x3其实看前面就知道，我对其也是因为有着部分的好桥段好演出盖过了大多缺点。 比如游戏的欠打磨感非常强，一些播片中途加载时居然有时候不是无缝的，一瞬间还看到原地站在刚刚的地方，再加上加载时还出bgm打破刚刚的氛围是很糟糕的一件事情。 前中期除了一部分看起来比较用力的地方，大多时候动作也都不太行。举例马娘其实动作大多是那几个模板，但是足够生动以及会调整人物站位其站桩对话都是很有趣的。学园偶像表现力应该是更进一步，虽然这样要求鸣潮不公平，但是确实马娘就是体验好，就算不提马娘，最近的方舟终末地内测人物站桩对话也是很生动的。 另一方面，游戏中的细节不知道是因为最终调整后导致非常不通顺还是单纯工期赶都不太能表现出来，就是硬靠大家去推敲猜测。例如最后从小卡分离利维坦还是什么的到底细节是怎么样的？飞出去的球应该怎么理解？坎的二次共鸣力量是恰如其分的助大卡撕开结界让漂泊者到来还是一直让大卡撑到了这个时候？漂泊者使用权能是比较唐突的，大家应该都还没意识到这方面的作用以及漂泊者已经上手了。 0x4综上2.2剧情整体算是令人满意的了，但细究体验还是上上下下的，也就是说什么时候下的多一些或者上的不够多就可能不太行。不过我比较高兴的还是这个故事没有那么ML也好看，虽然有几个地方比较媚宅，但也就是一种感觉比较仰慕憧憬的感觉+为了媚宅让你有了错觉罢了。当然也不是说他们ML不好，守岸人这种甚至超越了一般的爱，后劲特别强，但我还是比较在意人物的独立性完整性吧，守岸人就挺好的，你要能再写个这样的我肯定很高兴。 我想大致就这些了。","categories":[{"name":"Game","slug":"Game","permalink":"https://blog.kurenai.moe/categories/Game/"}],"tags":[{"name":"Gameplay","slug":"Gameplay","permalink":"https://blog.kurenai.moe/tags/Gameplay/"},{"name":"鸣潮","slug":"鸣潮","permalink":"https://blog.kurenai.moe/tags/%E9%B8%A3%E6%BD%AE/"},{"name":"Wuthering Waves","slug":"Wuthering-Waves","permalink":"https://blog.kurenai.moe/tags/Wuthering-Waves/"}]},{"title":"黑神话Gameplay","slug":"black-myth-gameplay","date":"2024-09-08T22:40:25.000Z","updated":"2025-09-20T21:44:22.000Z","comments":true,"path":"2024/09/08/black-myth-gameplay/","permalink":"https://blog.kurenai.moe/2024/09/08/black-myth-gameplay/","excerpt":"黑神话最开始看到的一些评测是让我对其 ARGP 中的 A 抱有比较大期望值的，但实际上手后的2小时其实是比较失望的。但后面升级后也算有一些改善，不过也不太能去期待他战斗动作能够有非常好的体验了。","text":"黑神话最开始看到的一些评测是让我对其 ARGP 中的 A 抱有比较大期望值的，但实际上手后的2小时其实是比较失望的。但后面升级后也算有一些改善，不过也不太能去期待他战斗动作能够有非常好的体验了。 地图 空气墙最大问题是没有统一的设计让你能够辨别这里是否有空气墙，包括一些跳跃可以上去的地方。 迷路起初都还好，只是探索欲比较旺盛的人可能会花很多时间，后面小西天雪山是地图又大，人物跑起来又慢，周围景色我是真不能辨别，我期间是逐渐失去耐心的。 人物性能韧性非常差，一些小攻击造成吃一套，你也同样不好立刻反击，比如A，通常都是狂按闪避了。 喝药非常慢，加上一些boss的一套combo，你很多时候是有药也没空喝。 妖怪技（精魄） 使用的时候会受伤 幽魂打断非常好，但是很容易空 闪避 完美闪避判定非常苛刻 多段攻击完美闪避体验非常糟糕，很多时候不如大闪出攻击范围 闪避只有第一段手感还好，后面非常粘手的感觉，有时候很难分辨到底闪到没有，加上初期轻攻击1段突进不够距离，闪出去基本就开始下个回合了 完美闪避后没有什么很好的回报 GP劈棍的GP 要求棍势，2段貌似也要求 会受伤，或者你可以完美闪避前面招式看最后一下，因为GP到的那一下是无伤的 2段很容易空 并不太能打断敌方招式，或者说能够打断的招式并不多 GP的节点并不那么自由，一般都要A一下稍微等等看boss攻击，用枪要简单一些，可以A完立即GP，另外3段的花棍会被打断导致GP手感很不好。 貌似并不能GP那种高伤技能，2段我也被高伤技能打断过 没GP到他是会后撤一点的，很容易GP拿一下也打不中 综上，高风险低收益 Boss战boss有那种虽然有明显前摇动作，但是攻击瞬间非常快，加上完美闪避判断苛刻，没有好回报，导致回合制体验非常严重，你不太想在boss回合内反制他。 有时候镜头很难判断boss出招的一个全貌，或者说你看不见boss的动作。 你的回合内如果突入boss攻击（其实就是你的回合时间太短还没放完招），你可以： 化身幽魂高打断（其实也是建议这样，因为经常空放boss到处跑会空），其他的暂时不知道好不好用在这个时候，但你会受伤 身法中散气可以做到后撤闪避的效果，打断也看起来还行 GP，通常没法GP，GP吃一套伤害非常感人的，除非算计好boss攻击的时候或者那种看起来非常简单的你可以GP，但闪完再GP是可以考虑的 也许你已经进入最后一段轻攻击，直接打下去造成打断，打断效果好像挺一般，这一下有一些韧性（但不多） 综上，你一般就是赶紧躲开等下个回合，因为上面有很多都有不短的冷却，而且还有些消耗法力值。或者也可以稍微周旋等冷却进行一套法术的长输出/与boss攻击中交互。 比较通解的是蓄力上去开局，蓄力换血，隐身蓄力，然后就是那些比较轮椅的套装了。有种你不太去找法术，安排使用法术或者搭配套装，你的难度曲线是会突然增高很多的，而一些好用的法术套路看起来跟boss交互性都比较差。 因为道中一些小怪有时候都是开挂无限喝药打死的，很多时候看起来都找不太到解法，基本就是跳过了，所以没什么特别记录。其他的有印象的，卡的比较久的就记录一下。 幽魂场地受到空气墙影响非常大，因为boss基本招式判定范围非常大，你会很想闪出一个大范围，然后就很容易碰到空气墙 虎先锋GP起来比较难而且吃后面几个连段的伤害，不是那么赚，最简单的还是回合制，躲过就打打，一般他打完会往回撤。 快慢刀可以有那种不好预测的长滞空下落攻击，几乎是背板，典型的那几拳跟刀的前两次砍看似还没开始打到你，但其实你就该闪了，而且这是完美闪避的时机，而且还是那种中间就间隔一小会的连闪，手感跟看到的感觉是不一样的。 一些长滞空的快慢刀经常安插在攻击间隔中，镜头机位低，很容易造成上面提到的boss动作根本看不清（看不见）。 中后期有那种化成石头后隐身一冲的技能，我不知道能不能打到隐身的它，打不到就是干站着准备躲技能了。 PS: 他镜头是真的有问题，有些时候你可以试试定身，机位直接让你仰望他，视角特别难受。 黄风大圣久仰大名的0帧起手投技，感觉上应该是起手动作的，起码我看到腿是在动的，但是很多动作腿都在动，我说实话通关了都没辨别出来，所以体感几乎是0帧起手，抓需范围很大。 起手基本就是蓄力+身外身法+AA途中看到攻击就定身+一套轻攻击+蓄力。后面稍微躲躲技能就好了，实际上技能还是很好躲的，不像是虎先锋不能够预测，基本是背板的，但是最后的龙卷风要注意一下，我可能幸运特别快就过了。 总体而言卡的比虎先锋短很多时间，也许技能上来了，前期一顿胖揍确实也大了很多血。但听说这里boss容易跳出空气墙外面导致你摸不到他，我因为一套下来用不了多久就开始转阶段，还没有感受到。 亢金龙镜头问题更加严重，而且经常帮你锁头，导致有时候都打不到尾巴。 基本就是看boss表演，你只要躲完跑过去蹭血就好了，因为我换了戳棍打，经常打不到它，感觉要立辊。 另外它投技虽然还好躲，但是依然是从很远的地方一下子突进过来，基本也不太能预测，要提前。 魔将·妙音更加糟糕的镜头问题，更加糟糕的锁定问题。打起来更多的也是看演出，交互还是少，我最开始都是蒙头一直修脚。 自己打后面打的没伤害，卡了很久就跑去看攻略了，基本就是打带红的脚（右前）让他倒下然后打头，平时有机会也可以摸到头，但是锁定很糟糕。 另外依然是看不懂的投技。 亢金星君卡了我特别久，技能非常不好躲，伤害还不低，特别是二阶段我甚至不知道什么时候输出好，每次碰两下就要被打，GP点我基本摸不到（指不定某些还是不让你GP的），蓄力还会被远程追击，这boss是不是必须上对策难度才没这么变态啊。 最后没办法只能够查攻略逃课了：喝酒上buff，开局三蓄，隐身再三蓄，AA开定身（或者看到开始攻击）再轻攻击一套，反正打到boss上天开石头人躲伤害，期间第一次满了释放特殊技，第二次满了等下来再打，化身解开后立即隐身三蓄，然后再打打开定身，然后随便打一下让boss上天，开定风珠再打基本就死了。 黄眉不知道应该算简单还是怎么样，打起来算是舒服的。 百眼魔君血压拉满ww，正面碰撞模型比实际看到的boss模型大一些导致你会被卡住，然后攻击判定的模型或者说大小却并不像碰撞模型那么大，你正面平A就是会被挡住根本没伤害，导致很多技能都会空，侧面虽然能摸到脚但是仍然是攻击判定很糟糕，很多时候都会空，加上人物本身锁定+技能招式追踪问题，你真的会觉得非常搞笑了。 后面虽然能打进3阶段但是缺少道具几乎被秒杀，就回头去找道具了，但是拿道具需要先去打毒敌大王再去打拿道具的boss，于是乎就跑去打毒敌大王了。 毒敌大王你几乎必须掌握操控人物的闪避性能或者说要求你就应该要完美闪避（熟悉boss），不然你就是一直挨揍。 毒敌大一套体操并不长，但是间隔并不短，或者说每套每套互相之间要打个好几套才有间隔，而且范围及其广，突进对人物来说也是非常远的，加上人物闪避性能，你很难有休息的时间，或者说你不能能够一直闪出去休息，更多的是看boss行动，找到空隙补血，不然就要集中精力一直闪避。 也许是我太过自信都没有加过血量，加上boss伤害不俗，一套体操你应该人就没了，特别是你有时候甚至没有掌握准时机想要用一些长演出的技能时，应该能吃上半管血，boss的韧性也是游离不定的，有时候时非常好打断的有时候就很强，大多感觉是某种保护机制生效了不让你一直连。 Anyway，我打到这里的时候已经逐渐对游戏失去兴趣了，原本还想正面不逃课不太依靠法术赖皮打法过boss，现在玩起来只有折磨，爽快度一直是找不太到的，故几乎打算在这里封盘了。 总体感想28小时，盘丝洞百眼魔君，GP没怎么练，目前也就试过带不能做简单aaa连招，通常都是赖皮一套法术打进残血（aaa看boss动作定身，aaa不能，看情况能不能打进4段棍势，劈棍重击，随便打打开隐身蓄力）。 战斗体操作验来说我觉得看似像只狼，但实际打起来更像是魂系稍微加强点动作。尽管技能多，但我几乎还是一直在平A。然后我回头去看了一下只狼，战斗体验来说由于经常性的格挡弹刀，攻守交换也非常频繁（拉长了应该也比较像黑猴回合制了），期间由于人物性能其实可以穿插一些有趣的道具（冷却以及资源数量都还可以），平A等等，整体是非常平滑的，加上boss的设计，我不太会在意只狼AAA的贫乏，实际上我应该都是专注于跟boss的交互，AAA都是半自动的见缝插针。黑猴整体有很多boss爆发回，长演出，特别是神经刀让你整体体验都没有那么爽快，有时候甚至觉得是比较折磨的，而且AAA你其实不能够半自动，还有预输入问题导致你的精力不单只是集中在跟boss周旋，还要在意你的出招问题，特别还有一些幽默的长演出技能吃boss伤害的问题。在诸多问题的加持下我觉得黑猴战斗更多时候对我来说是折磨，我除了虎先锋认真对待应对每个技能外，其他大多都是追求着0交互的战斗。 美术应该是黑猴最大的优点了，还有良好的配音（毕竟看起来就单纯是非动画片的配音，应该是那些演员熟悉的领域），然后就是丰富的敌人跟boss，除此之外大多都让我感到印象差。 boss设计的那种神经刀让我感到没意思，特别是一些拳脚招式大多让我感到无法理喻，虎先锋跟不能的扫堂腿看似极其无力其实是极具伤害的，一些招式应该需要更高的速度感他以缓慢的速度滞空出招，你也很多时候不觉得这个招式应该以这样的速度进行（预测招式的动作），这其中也带有没有速度感动作也没有力量感导致的奇怪动作打击伤害让人摸不着头脑。与之相对，有一些技能是攻击判定时动作极其迅速你需要背板，就比如一些看似前摇蓄力慢，实则正真你能通过动作判定的帧数应该很少，所以需要靠背板。 故事来说我没有去认真看，毕竟对原著也不熟悉。播片的动画以美术来说还是很有意思的，以故事来说就挺一般，甚至小西天章节结尾动画最后那个时金蝉子吗？整一个活脱脱非那个时代的帅哥。","categories":[{"name":"Game","slug":"Game","permalink":"https://blog.kurenai.moe/categories/Game/"}],"tags":[{"name":"黑神话","slug":"黑神话","permalink":"https://blog.kurenai.moe/tags/%E9%BB%91%E7%A5%9E%E8%AF%9D/"},{"name":"Black Myth","slug":"Black-Myth","permalink":"https://blog.kurenai.moe/tags/Black-Myth/"},{"name":"Gameplay","slug":"Gameplay","permalink":"https://blog.kurenai.moe/tags/Gameplay/"}]},{"title":"Spring JPA 笔记 01","slug":"spring-jpa-notes-01","date":"2024-08-03T23:22:00.000Z","updated":"2025-06-04T08:50:50.000Z","comments":true,"path":"2024/08/03/spring-jpa-notes-01/","permalink":"https://blog.kurenai.moe/2024/08/03/spring-jpa-notes-01/","excerpt":"记录一下最近工作用jpa的一些心得，或者说就是坑（笑）","text":"记录一下最近工作用jpa的一些心得，或者说就是坑（笑） Banner Illustration: 荻pote非常通透的画面感，以及大多都是初/高中生。图里面一般都带有一定的叙事。但其实很多细节感觉还是不太好的，例如本图的衣服皱褶。但是个人风格非常明显，我还是很喜欢的。https://www.pixiv.net/artworks/86588827 关联查询众所周知，JPA Fetch Type 有 Eager 和 Lazy，而 Eager 只能有一个，那么其他就要在读取的时候（例如 getter）才会查库。这在某些量比较大的关联的表是不友好的，甚至有时候并不想查出来，这也困扰着我现在做的项目。 经过一番搜索，我看到大家都推荐用 Entity Graph 来解决这个问题，可是新的问题出现了，官方的 Entity Graph 是不支持动态传入的，所以我又找到了 spring-data-jpa-entity-graph 这个项目，允许运行时传入 Entity Graph，所以这个问题也暂时告一段落了。 但是好景不长，由于项目本身是接手的以前的团队，另外实体类的关联规划也都早就写好了，不太可能改，而原想团队写这些实体类的时候几乎就是滥用的程度，想要查什么或者看起来就是能够关联上的就直接写进去，这让我们在开发报表类的需求时极其头疼，因为我们发现 JPA/Hibernate 就算你不去动那些懒加载的关联项，也会因为某种原因被触发，而且就我们项目来说几乎是 Repository 方法调用拿到结果赋值给一个对象的时候就发生了，再往里面跟踪我就实在是不太能够理解代码了，而且看起来几乎没有办法阻止。 所以我们就开始考虑直接用 Entity Graph 对那些懒加载（假如他会，因为不是所有懒加载都会去查询）的关联项都直接查询出来，毕竟比起懒加载一条一条查，一条 sql 查出来通常是更快的。可是新的问题又出现了，因为其关联的对象巨大的，层层加码，导致一条 sql 关联的表实在是太多了（而且可能是重复关联）。 几经周折，我们发现对于一些巨大的表来说，拆分查询，也就是查出来后把所有的 id 收集到后再去查库，会有更好的性能表现。但对于更加复杂的（我们报表开发几乎是基于存储过程再改写成 java 的）sql 就只能够用 native query（也就是直接写 sql）了。 PS: 用 id 查询的时候有一个坑，就是巨大的 id 量也会导致其查询非常缓慢，所以有必要切分成几次查询，每次查2k左右 对象映射/空元素空元素出现实际上代表着该条目是有数据的，但是在 JPA/Hibernate 在进行对象映射的时候，由于该 id 为null，亦或者是这是一个组合 id，其中有一个字段是null的时候，就会发生。 虽然常用数据库可以写入条件限制这个情况的发生，但不幸的是我们现在用的数据库 Sybase 其实是没有主键的说法的，所以我们只是用 index 来做限制以达到类似主键的限制的目的。但是其不对该字段为空做限制，而且原先业务数据库所存在的数据就是这样，要么对数据库里的数据进行清洗，要么就是在代码层面兼容。 PS: 这里面仍然有一个问题，实际上我们数据库是空白串，char固定长度类型，但是仍然在get值时返回给到null，这块还没有确定是不是单纯数据库驱动的问题。 由于这些数据都是已经在用的了，做修改是非常大的风险， 而且也不单纯只是我们项目在用，除非客户本身已经考虑数据清洗/迁移了，所以数据清洗是不做考虑的。 所以我门最终是以修改 JPA/Hibernate 的数据映射达成的，就是对特定字段添加 mapper 注解调用自定义映射逻辑，把他改成空串。 重点在 nullSafeGet 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class NullToEmptyCharType implements UserType &#123; @Override public int[] sqlTypes() &#123; return new int[]&#123;Types.VARCHAR&#125;; &#125; @Override public Class&lt;?&gt; returnedClass() &#123; return String.class; &#125; @Override public boolean equals(Object x, Object y) throws HibernateException &#123; if (x == null &amp;&amp; y == null) &#123; return true; &#125; else if (x != null &amp;&amp; y != null) &#123; return x == y || x.equals(y); &#125; else &#123; return false; &#125; &#125; @Override public int hashCode(Object x) throws HibernateException &#123; return Objects.hash(x); &#125; @Override public Object nullSafeGet(ResultSet rs, String[] names, SharedSessionContractImplementor session, Object owner) throws HibernateException, SQLException &#123; String value = rs.getString(names[0]); // 就是这一步拿出的value就算数据库是空白串，这里的值也是null if (value == null) &#123; return CommonUtil.EMPTY_STRING; &#125; return value; &#125; @Override public void nullSafeSet(PreparedStatement st, Object value, int index, SharedSessionContractImplementor session) throws HibernateException, SQLException &#123; if (value == null) &#123; st.setNull(index, Types.VARCHAR); &#125; else &#123; String phone = value.toString(); st.setString(index, phone); &#125; &#125; @Override public Object deepCopy(Object value) throws HibernateException &#123; return value; &#125; /** * Whether the type is variable */ @Override public boolean isMutable() &#123; return false; &#125; /** * This method is called when the type is written to the second-level cache */ @Override public Serializable disassemble(Object value) throws HibernateException &#123; return (Serializable) value; &#125; /** * This method is called when data is fetched from the level 2 cache */ @Override public Object assemble(Serializable cached, Object owner) throws HibernateException &#123; return cached; &#125; @Override public Object replace(Object original, Object target, Object owner) throws HibernateException &#123; return original; &#125;&#125; Native Query with Stream由于上面说到过我们项目会写 Dynamic SQL，也就是会调用 nativeQuery 方法做查询，就碰上了奇怪的问题，这个我暂时没有搞明白是怎么回事。简单说就是最后调用 getResultStream 获取结果的话，会导致异常的发生，说这个 Stream 已经执行过 terminal 操作，也就是执行了那些会触发 Stream 执行的方法。 Fix 也很简单，单纯就是不要用 Stream 接收他这个结果集，只用 List 操作。或者是用一个新的 List 接收再去做操作。","categories":[{"name":"编程","slug":"编程","permalink":"https://blog.kurenai.moe/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://blog.kurenai.moe/tags/JPA/"}]},{"title":"GraalVM With Spring","slug":"graalvm-with-spring-boot","date":"2023-07-12T00:21:00.000Z","updated":"2024-07-31T07:30:44.000Z","comments":true,"path":"2023/07/12/graalvm-with-spring-boot/","permalink":"https://blog.kurenai.moe/2023/07/12/graalvm-with-spring-boot/","excerpt":"最初看见 GraalVM 的时候我就想到 Make jvm great again! ！！实际上我也在之前尝试过几次，但都是不理想或者失败了。这次我看到 Spring Boot 3 对 GraalVM 的支持更加完善了，就又想跑过来试试了，毕竟写 Kotlin 编译成 Native 还是太香了！（Kotlin 香，Native 香，香两次，简直香麻了）同样这次也都还是做一些折腾的记录。","text":"最初看见 GraalVM 的时候我就想到 Make jvm great again! ！！实际上我也在之前尝试过几次，但都是不理想或者失败了。这次我看到 Spring Boot 3 对 GraalVM 的支持更加完善了，就又想跑过来试试了，毕竟写 Kotlin 编译成 Native 还是太香了！（Kotlin 香，Native 香，香两次，简直香麻了）同样这次也都还是做一些折腾的记录。 封面：画师是我岳父おにねこ，封面链接。就说这位画师非常适合黑色哥特萝莉，201x年初时其实脸跟一些细节都让人感觉比较潦草，但是非常个人风格，背景也很好。现在整体都相较要好很多，细节要更加多。 前言GraalVM 与传统在 JVM 中运行的 JIT 编译不同，他是 AOT 编译。由于去掉了 JVM 后一些运行时的动态分析就会失效，如反射，代理，JNI，SPI 等等，而这里面一些资源也要显式声明，所以你需要大量的去告诉编译器这个类实际上运行时是谁，让它去分析这个类、资源的信息，最后才能够在运行时找到。 这几乎就是转 GraalVM 的全部工作了，但不得不说这些工作量还是很大的。最初时大多项目都没有提供支持，导致你需要自己等待编译，然后运行报错看提示再去告诉编译器需要分析什么东西。 如今，大多常用的包都有给出一些反射、代理或者资源的配置了，所以我又准备尝试了。 环境准备WindowsWindows 环境非常恶劣，起初我几乎放弃了。就算是现在我也不能说我真的就了解怎么搭建环境了。所以珍惜生命远离 Windows Ok，其实现在 GraalVM 的官网上面已经放出了一篇教程，只需要安装好 vs 当中的一些组件即可 重点：找到x64 Native Tools Command Prompt for VS 2022这个快捷方式，打开进入cmd，可以看到有个x64的输出，这个环境就算准备好了，2022可以是别的，但是前缀应该就是这些，x86是不支持的，交叉编译不知道。 最后配置一下环境变量 GRAALVM_HOME 跟 JAVA_HOME 就好了了，这是为了 gradle 的 graalvm 的插件（org.graalvm.buildtools.native）做准备。 其他其他大概就不太需要说明了，只要装上 GraalVM 的 sdk 就行了。 GraalVM 配置GraalVM 的配置是放在 resource/META-INF/native-image/ 下面，我不太记得非 spring 项目下是不是默认读取这个目录下的配置了，这块现在这个仓库有维护一些配置，可以直接拿过来用，主要是 copy 里面的 reflect-config.json, proxy-config.json，jni-config.json，resource-config.json Spring 配置依赖什么的这个也没有什么特别说的，直接在start.spring.io上面选好依赖，查看它配置文件怎么写就好了。 RuntimeHintsRegistrar因为自己手写 json 不太可能的（手写是不可能手写的，这辈子都不可能），毕竟太多了不是人干的活，所以 GraalVM 有一个 agent 可以分析一下运行时情况。但是也不一定能够分析全，例如运行时并没有跑某几段代码等，所以我们就需要RuntimeHintsRegistrar来代码生成。 这个类貌似GraalVM也有提供，但是因为用的 Spring，GraalVM 提供的就没有去研究了。 123456789101112131415161718192021222324252627282930313233343536373839404142// hints 和 classLoader 都是实现这个类的`registerHints`方法传入的参数// 私有类无法访问时hints.reflection().registerTypeIfPresent(classLoader, &quot;com.github.benmanes.caffeine.cache.PSWMW&quot;, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)// 一般情况，后面的 MemberCategory 类型就是要注册的东西，可以是全部方法、字段或者是 public 的方法、字段等等hints.reflection().registerType(ConstructorDetector::class.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_METHODS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_CLASSES)// 拥有内部类的时候AtomicLongFieldUpdater::class.java.declaredClasses.forEach &#123; hints.reflection().registerTypeIfPresent(classLoader, it.name, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_METHODS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_CLASSES)&#125;// 一些基础类型的注册hints.jni().registerType(java.lang.Boolean::class.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)hints.jni().registerType(java.lang.Integer::class.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)hints.jni().registerType(java.lang.Long::class.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)hints.jni().registerType(java.lang.Double::class.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)hints.jni().registerType(java.lang.String::class.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)hints.jni().registerType(java.util.Arrays::class.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)hints.jni().registerType(Array::class.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)hints.jni().registerType(IntArray::class.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)hints.jni().registerType(LongArray::class.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)hints.jni().registerType(DoubleArray::class.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)hints.jni().registerType(BooleanArray::class.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)// jni内部类的注册TdApi::class.nestedClasses.forEach &#123; clazz -&gt; if (clazz.isSubclassOf(TdApi.Function::class).not()) &#123; hints.jni().registerTypeIfPresent(classLoader, &quot;$&#123;clazz.name&#125;[]&quot;) &#125;// clazz.java.declaredMethods.forEach &#123;// hints.jni().registerMethod(it, ExecutableMode.INVOKE)// &#125;// clazz.java.fields.forEach &#123;// hints.jni().registerField(it)// &#125; hints.reflection().registerType(clazz.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS) hints.jni().registerType(clazz.java, MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)&#125;// 资源的注册hints.resources().registerPattern(&quot;META-INF/tdlightjni/*&quot;) 写完这个类后，找个@Configuration的类或者程序入口类添加@ImportRuntimeHints(YourHintsRegirar::class)，这样他就会编译的时候在build/generated/aotResources下生成对应的配置文件，可以打开检查一下生成有没有问题。 编译Ok，万事俱备了，就剩下编译了。 Windows编译必须要在刚刚说到的x64 Native Tools Command Prompt for VS 2022当中执行命令。 执行gradle nativeCompile等待编译完成。 编译完成会在build/native/nativeCompile目录下找到可执行文件，执行即可。 结语这东西我 5600X 几乎需要花 3min+ 编译，当你不太确定或者一些库用了大量反射或者大量个人库但是没有相关配置的时候，你可能需要给他写大量的配置文件，重复 N 次编译，所以如果可以，还是在配置比较高的情况下玩，不然一天很快过去的www","categories":[{"name":"折腾记录","slug":"折腾记录","permalink":"https://blog.kurenai.moe/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"GraalVM","slug":"GraalVM","permalink":"https://blog.kurenai.moe/tags/GraalVM/"}]},{"title":"用Gradle构建lib分离的jar包","slug":"build-thin-jar-with-external-lib-by-gradle","date":"2022-06-23T21:52:00.000Z","updated":"2022-07-01T05:54:01.000Z","comments":true,"path":"2022/06/23/build-thin-jar-with-external-lib-by-gradle/","permalink":"https://blog.kurenai.moe/2022/06/23/build-thin-jar-with-external-lib-by-gradle/","excerpt":"如果平时比较多使用docker部署，那么为了节省部署的时间，一般会把一些不太变化的东西放在比较前面写作为一层，分层处理后可以利用编译的缓存快速构建出镜像。 因此，如果一个jar包是分离lib的话就可以做灵活的分层处理了。","text":"如果平时比较多使用docker部署，那么为了节省部署的时间，一般会把一些不太变化的东西放在比较前面写作为一层，分层处理后可以利用编译的缓存快速构建出镜像。 因此，如果一个jar包是分离lib的话就可以做灵活的分层处理了。 封面：Shadowverse 5周年贺图，角色是我女儿雪华。BTW，这个角色的cv是刚出道的时候非常呆萌非常贪吃的もちょ。 0x01最近由于接触了一下Quarkus，发现其打包jar的方式非常棒，分离了lib，最终推送docker镜像时利用缓存只需要1M不到的数据量，虽然我以前是知道maven有类似的插件的，但是由于最近我完全入坑gradle了，也尝试过找类似的插件但都未果，此次因为尝到了甜头，以及我不想要绑定quarkus框架所以又去找了一下解决方案。 0x02首先Jar包内是有一个META-INF/MANIFEST.MF这样的文件，里面我只挑能够达成jar包跟lib分离目的的参数： Main-Class 这是指定程序入口的参数，一般就是main方法所在的class，Kotlin的class需要加上Kt的后缀才正确。 这个一般打成jar运行是基础配置，不然无法运行。 Class-Path 这个就是需要加载的lib的配置了，需要对每个lib包都做声明，空格分割。 下一步是对Gradle的jar任务做修改，让其排除所有的*.jar文件，并自定义一个删除以及拷贝lib的任务让其依赖。这需要了解一下Gradle如何自定义一个task以及jar任务如何修改。 0x03了解完上面说的两点，就可以直接上代码了： 1234567891011121314151617181920tasks.register&lt;Delete&gt;(&quot;clearLib&quot;) &#123; //清除lib delete(&quot;$buildDir/libs/lib&quot;)&#125;tasks.register&lt;Copy&gt;(&quot;copyLib&quot;) &#123; //拷贝lib from(configurations.runtimeClasspath) //从运行时目录 into(&quot;$buildDir/libs/lib&quot;) //到打包目录&#125;tasks.jar &#123; dependsOn(&quot;clearLib&quot;) //依赖清除和拷贝lib任务 dependsOn(&quot;copyLib&quot;) exclude(&quot;**/*.jar&quot;) //打包时排除jar文件（不打包成fat jar） manifest &#123; attributes[&quot;Manifest-Version&quot;] = &quot;1.0&quot; attributes[&quot;Multi-Release&quot;] = &quot;true&quot; attributes[&quot;Main-Class&quot;] = &quot;moe.kurenai.bot.BgmApplicationKt&quot; //main方法所在的class，我这个例子是用的Kotlin所以带有Kt后缀 attributes[&quot;Class-Path&quot;] = configurations.runtimeClasspath.get().files.map &#123; &quot;lib/$&#123;it.name&#125;&quot; &#125;.joinToString(&quot; &quot;) //构建出 lib/包名 的字符串并用空格分隔 &#125;&#125; 最终效果 1234567891011121314151617181920212223242526Manifest-Version: 1.0Multi-Release: trueMain-Class: moe.kurenai.bot.BgmApplicationKtClass-Path: lib/bangumi-sdk-0.0.1-SNAPSHOT.jar lib/td-light-sdk-0.0.1-SN APSHOT.jar lib/kotlinx-coroutines-core-jvm-1.6.1.jar lib/kotlin-stdlib- jdk8-1.6.21.jar lib/simple-cache-1.2.0-SNAPSHOT.jar lib/redisson-3.17.1 .jar lib/reflections-0.10.2.jar lib/log4j-core-2.17.1.jar lib/log4j-api -2.17.1.jar lib/disruptor-3.4.4.jar lib/jackson-module-kotlin-2.13.1.ja r lib/jackson-dataformat-yaml-2.13.1.jar lib/kotlin-stdlib-jdk7-1.6.21. jar lib/kotlin-reflect-1.6.21.jar lib/kotlin-stdlib-1.6.21.jar lib/jack son-datatype-jdk8-2.13.1.jar lib/jackson-datatype-jsr310-2.13.1.jar lib /jackson-databind-2.13.1.jar lib/lettuce-core-6.1.6.RELEASE.jar lib/rea ctor-core-3.4.17.jar lib/jackson-core-2.13.1.jar lib/jackson-annotation s-2.13.1.jar lib/commons-lang3-3.12.0.jar lib/commons-pool2-2.10.0.jar lib/commons-codec-1.3.jar lib/kryo-5.3.0.jar lib/netty-resolver-dns-4.1 .74.Final.jar lib/netty-handler-4.1.74.Final.jar lib/netty-codec-dns-4. 1.74.Final.jar lib/netty-codec-4.1.74.Final.jar lib/netty-transport-4.1 .74.Final.jar lib/netty-buffer-4.1.74.Final.jar lib/netty-resolver-4.1. 74.Final.jar lib/netty-common-4.1.74.Final.jar lib/cache-api-1.1.1.jar lib/rxjava-3.0.12.jar lib/reactive-streams-1.0.3.jar lib/jboss-marshall ing-river-2.0.11.Final.jar lib/jboss-marshalling-2.0.11.Final.jar lib/s lf4j-api-1.7.36.jar lib/byte-buddy-1.11.0.jar lib/jodd-bean-5.1.6.jar l ib/javassist-3.28.0-GA.jar lib/jsr305-3.0.2.jar lib/kotlin-stdlib-commo n-1.6.21.jar lib/annotations-13.0.jar lib/reflectasm-1.11.9.jar lib/obj enesis-3.2.jar lib/minlog-1.3.1.jar lib/snakeyaml-1.28.jar lib/netty-tc native-classes-2.0.48.Final.jar lib/jodd-core-5.1.6.jar 0x03上面只是比较简单的示例，你还可以对你不经常变动的包分到另一个目录当中去（例如bangumi-sdk-0.0.1-SNAPSHOT.jar这个包是我自己写的sdk，会经常变动），这样更加能够利用好缓存构建docker镜像，实际上quarkus是分了4个文件夹。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.kurenai.moe/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.kurenai.moe/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://blog.kurenai.moe/tags/Kotlin/"},{"name":"Gradle","slug":"Gradle","permalink":"https://blog.kurenai.moe/tags/Gradle/"}]},{"title":"Kotlin使用记录01","slug":"lean-kotlin-01","date":"2021-12-17T09:18:07.000Z","updated":"2023-01-06T20:14:19.000Z","comments":true,"path":"2021/12/17/lean-kotlin-01/","permalink":"https://blog.kurenai.moe/2021/12/17/lean-kotlin-01/","excerpt":"Kotlin是一个完全兼容java的jvm语言，但不是说什么地方都跟java一样，只是说可以完全调用java。而也有于此，导致Kotlin一些使用方面需要注意一些东西，例如标准库不一定是跟JDK用法相同。不过我也没有打算完全记录，可能更多的还是做个TODO列表防健忘","text":"Kotlin是一个完全兼容java的jvm语言，但不是说什么地方都跟java一样，只是说可以完全调用java。而也有于此，导致Kotlin一些使用方面需要注意一些东西，例如标准库不一定是跟JDK用法相同。不过我也没有打算完全记录，可能更多的还是做个TODO列表防健忘 封面逆光剑，Fate/hollow ataraxia中バゼット使用的武器之一。在Fate/unlimited codes中与Lancer的Gae Bolg同时发动会有奇效：由于皆为因果逆转宝具——注定命中对方的心脏；后发但会先贯穿对方。两方会由于逆转因果失败而同时受到宝具伤害后倒地。 Kotlin的标准库Kotlin的标准库是有别于Java的，注意调用时点进去看是什么包下面的。其实好像也就想到了list跟map List, Map等List和Map是有些非常方便的方法构建的，listOf(&quot;xxx&quot;, &quot;xxx&quot;), mapOf(&quot;xxx&quot; to &quot;xxx&quot;, &quot;xxx&quot; to &quot;xxx&quot;)，这些用起来非常爽快。但需要注意这里返回的类型是Kotlin下的List跟Map，它所提供的方法很有限，都是不可变的方法。但具体返回的对象则不一定是不可变的，具体点进方法内看就知道了。那么我们需要一个可变的List或是Map时就需要让方法返回MutableList或是MutableMap的对象，可以用mutableOfList()或mutableOfMap()，当然你也可以用is去看是不是某类型的实例，大多其实还是返回的JDK里面的list跟map。 扩展函数Kotlin要说我感到最爽的东西，大概除了协程就是这个了。 1234567891011121314object MarkdownUtil &#123; private val formatChar = &quot;_*[]()~`&gt;#+-=|&#123;&#125;.!&quot;.toCharArray() //扩展函数，可以直接就等于一个方法，也可以调用该类内部方法，this指代的就是当前调用这个方法的String对象 fun String.format2Markdown(): String = MarkdownUtil.format(this) private fun format(target: String): String &#123; var result = target for (c in formatChar) &#123; result = result.replace(c.toString(), &quot;\\\\$c&quot;) &#125; return result &#125;&#125; 上面的例子是我写Telegram Bot时写的一个方法，用来转换掉markdown的特殊字符，调用时只需要&quot;Some String&quot;.format2Markdown()，这就像String类扩展了一个方法一样，当你有许多这样的方法的时候，也许你就可以像链式调用一样写起来特别爽快了。 这样对于一些非自己项目内的代码进行非常简单的扩展也会大大增加写代码的效率，而不需要额外调用一个工具类对该变量做处理（不需要管其他工具类，只要点出来就好了）等等。 LambdaKotlin的Lambda整体感觉是要强于java很多的，java很多情况下的推断都不太行导致很多地方没法使用，另外一个是Kotlin对Lambda的支持要能够放入更多的地方，例如你可以直接将一串Lambda赋值于一个变量而不需要特别的写一个函数接口，拿到的一个类型就是Unit。换句话说，函数是kotlin的一等公民。 Type safety类型安全也是Kotlin的一个区别于java的特色，虽然java其实可以用Optional作为代替，但是Kotlin也是可以使用的。 但Kotlin自身的类型安全是你声明时是否声明一个空变量，而后编译的时候就给你检测报错，并且强制要求你做一次判空，但Kotlin对判空进行了简化，用value?.doSomeThing()的方式先做判空，若是空则不会调用后面的doSomeThing方法。 但实际上强制你做类型声明的时候生命是否为空也是很烦人的，因为后面你到哪里都要做一次判空，虽然Kotlin能够推断当前的变量是否为空而后不需要判空，但他无法对变量内部的成员变量做判断，就算你判空过一次他也无法后面不需要判空，虽然可以赋值到当前的变量当中但是仍然是比较麻烦的。（这个后面类型推断会提到） 那么这个时候其实可以考虑用Java写POJO类，Kotlin对Java类都是不做强制要求判空的。 或者就需要煞费苦心分别分开不同的类比如，对接其他API的时候实际上返回的是一个聚合了很多东西的类，不同情况下不同的字段是有可能空或者非空的，如果都用一个类就会造成几乎所有字段都是可能空的尴尬，那么分开几个类型来接受就能够确切的知道当前的哪些字段是否空了。比如两种响应数据都含有data字段，但是data里面的name字段其中一种响应是不存在的；或者是可空的，另一种是一定非空，那么我们可以分成两个类去分别维护这两个响应数据结构，这样也许就比较符合我们想要的type-safe了。 推断Kotlin的推断能力在上面也有提到，再结合IDE就会边得异常爽快，例如上面提到的，如果这个变量进行过判空操作，后面就会自动的认为这个变量是非空的而不需要再次强制要求判空。实际这个是推断当前变量为非空类型，所以后面不需要判空。 又比如java当中非常繁琐的一种操作是if a instanceOf B，b = (B)a，然后用这个b变量操作，而Kotlin直接is一次判定为真后自动推断你这个变量就是某类型，而后可以直接用该变量调用该类型的方法。 123if (a is B) &#123; a.bClassMethod()&#125; 而这些在IDE上是都有提示的，最典型的就是val a = &quot;123&quot;在IDE当中是可以显示a的类型而不需要再手动定义类型了，当然你也可以显式声明类型。 协程这个留在最后讲其实主要我也不是特别熟，但不得不说这也是Kotlin的一大爽点吧。Kotlin的协程是一种无栈协程，他没有直接纳入Kotlin标准库当中，这样可以提高灵活性而不需要被标准库绑架。它比起大多的异步编程框架还是爽上不少的，毕竟可以直接写类似同步代码的代码达到异步编程的效果实在太棒了。但说实话我在写自己项目时，也有一些不解的地方，或者说我还不太了解它的运行轨迹。 现在了解到的就是，实际上他是做了一个标记，类似占位符，提交这段代码到线程执行，然后马上看执行结果，若是完成则返回结果，否则就是一个占位符（我没有看过源码，也不打保票就是这样，毕竟我自己写代码的时候还是有一些问题的），而只有当查看执行结果没有完成时才算是开始跑协程，不然跟普通跑代码区别不是很大。 一些问题 在运行一些长时间保持运行的项目当中，容易造成内部卡死。 e.g. 1234567891011scope.launch &#123; while (isActive) &#123; try &#123; feedAndSend(rss, group) delay(1000 * 60) &#125; catch (e: Exception) &#123; log.error(e) &#123; &quot;执行订阅出错。&quot; &#125; &#125; &#125; log.warn &#123; &quot;Coroutine was inactive.&quot; &#125;&#125; 另外还有类似接收到服务器发送的信息进行处理，运行久了就会无报错信息卡住不动，但最初的是时候我使用Dispatch.IO，之后我自己构建线程池指定队列长度以及线程配置后就还没发生过问题。 未完待续…","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://blog.kurenai.moe/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://blog.kurenai.moe/tags/Kotlin/"},{"name":"协程","slug":"协程","permalink":"https://blog.kurenai.moe/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"Java并发编程——双检锁单例模式","slug":"juc-dcl-singleton","date":"2021-06-16T11:19:12.000Z","updated":"2021-06-16T07:25:35.000Z","comments":true,"path":"2021/06/16/juc-dcl-singleton/","permalink":"https://blog.kurenai.moe/2021/06/16/juc-dcl-singleton/","excerpt":"记录一下双检锁单例模式是怎么一回事","text":"记录一下双检锁单例模式是怎么一回事 封面 pixiv id 64535234 0x01懒汉单例模式是无法保证线程安全的 12345678910111213141516public class Singleton &#123; private static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; //多个线程同时通过if判断新建实例，违反单例的初衷 singleton = new Singleton(); &#125; return singleton; &#125;&#125; 即当线程A通过if判断，但还未创建实例，此时线程B也能够通过if判断，那么就会对重复创建实例违反单例的初衷。 0x02那么我们为了保证线程安全，引入synchronized进行同步处理 123456789101112131415public class Singleton &#123; private static Singleton singleton; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (singleton == null) &#123; //此时最多只会有一个线程进入if判断中 singleton = new Singleton(); &#125; return singleton; &#125;&#125; 此时就只有一个线程能够获取锁进入到if判断创建实例了。 synchronized 偏向锁，自旋锁，轻量级锁，重量级锁 通过 synchronized 加锁，第一个线程获取的锁为偏向锁，这时有其他线程参与锁竞争，升级为轻量级锁，其他线程通过循环的方式尝试获得锁，称自旋锁。若果自旋的次数达到一定的阈值，则升级为重量级锁。 需要注意的是，在第二个线程获取锁时，会先判断第一个线程是否仍然存活，如果不存活，不会升级为轻量级锁。 0x03可是现在由于同步处理导致每次获取实例都需要竞争获取锁导致效率非常低下，所以我们应该在最外面做一次if判断来让大多数时候直接return实例而不是进行锁的竞争。 12345678910111213141516171819public class Singleton &#123; private static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; //为了快速返回而不进入锁的竞争 synchronized (Singleton.class) &#123; //以当前类作为锁 if (singleton == null) &#123; //此时最多只会有一个线程进入if判断中 singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 而这就是双检锁（双重检查锁，Double check lock，DCL）。 0x04但这里其实还是没有彻底解决多线程的问题，因为new Object分为三个步骤： 分配内存空间 初始化对象信息 将内存空间引用赋值给变量 如果这当中指令重排了，在还没有初始化对象的时候就把地址赋值给了变量，此时在最外层的if判断变量不为空，因为有地址，这时候就会拿到一个未经初始化的变量。所以我们还需要用volatile修饰变量 12345678910111213141516171819public class Singleton &#123; private static volatile Singleton singleton; //避免指令重排序 private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; //为了快速返回而不进入锁的竞争 synchronized (Singleton.class) &#123; //以当前类作为锁 if (singleton == null) &#123; //此时最多只会有一个线程进入if判断中 singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; volatile 在多线程环境下，保证变量的可见性。使用了 volatile 修饰变量后，在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。 禁止 JVM 指令重排序。","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://blog.kurenai.moe/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.kurenai.moe/tags/Java/"},{"name":"J.U.C","slug":"J-U-C","permalink":"https://blog.kurenai.moe/tags/J-U-C/"}]},{"title":"面试题笔记01","slug":"interview-note-01","date":"2021-05-17T09:18:07.000Z","updated":"2021-05-17T08:32:54.000Z","comments":true,"path":"2021/05/17/interview-note-01/","permalink":"https://blog.kurenai.moe/2021/05/17/interview-note-01/","excerpt":"记录一下看过的一些面试题。","text":"记录一下看过的一些面试题。 封面这位画师的脸以及上色很有特点，稍微留意一下很容易就能够辨别出来了，只是表情总给人一种同样的感觉whttps://twitter.com/__LM7__/status/1379416474293465090 MQ接收到消息后无法查询到或者是旧的状态原因 数据库回滚 数据库事务未提交 解决办法 可以尝试将mq放在数据库事务之后执行。 可以利用@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)监听spring事务afterCommit阶段。 123456789101112131415@Transactionalpublic boolean saveFoo(FooEntity fooEntity) throws InterruptedException &#123; log.error(&quot;start insert foo&quot;); fooRepository.save(fooEntity); publisher.publishEvent(new MyTransactionEvent(fooEntity.getFooName())); log.error(&quot;end insert foo&quot;); Thread.currentThread().sleep(2000); log.error(&quot;to commit insert&quot;); return true;&#125;@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)public void afterCommit(MyTransactionEvent event) &#123; log.error(&quot;after commit then send event &#123;&#125;&quot;, event); log.error(&quot;after commit then send event &#123;&#125;&quot;, event.getName());&#125; 发送的spring事件会在监听到AFTER_COMMIT时执行 参考：https://blog.csdn.net/little_kelvin/article/details/111330768 MQ偶然接收到重复消息接收端消费了消息但是没有向broker发送ack或者broker没有接收到ack，导致broker将消息再次入队被其他接收端或同一个接收端消费，造成了重复消费消息 接收端方法做幂等：新增，则可以在消息做一个唯一主键，重复了则会异常，保证数据库没有脏数据。修改，一般都为幂等，修改多少次一般都是一样的结果。 如果还是比较困难，则用redis记录每次消费并生成全局唯一键&lt;id,message&gt;，每次消费查询一次redis，存在消费记录则不进行消费（处理） 熔断与服务降级当请求某个服务超时或是响应过慢，并在一定时间内次数达到一定阈值，为了防止调用链路响应过长而引发的服务雪崩，我们将暂时不去请求这个服务， 而是调用降级方法，并下线该服务。期间一般会在过去一定时间后，尝试再次请求该服务，获得响应后才会上线，不然都将是调用降级方法。 例如Hystrix，它有一个滑动时间窗的概念，在这个滑动的时间窗内（默认20s），错误率达到阈值（默认50%）则将打开熔断器，并经过一段时间之后（默认5s）再次执行一次检测是否应该打开熔断器。熔断器在打开期间，调用此服务将直接返回失败（服务降级），不再远程调用。 注意服务降级不一定伴随着熔断出现，他还可能是开关降级、限流降级。但是熔断是一定会出现服务降级的。即熔断是服务降级的子集 ps: 服务雪崩是指由于调用链路当中，下游的服务响应太慢或者超时导致上游服务的请求得不到释放， 逐渐导致连接数达到上限从而又对上游服务造成影响 ，如此往复直到最上游服务难以承受压力（超过最大连接数等）","categories":[{"name":"编程","slug":"编程","permalink":"https://blog.kurenai.moe/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"MQ","slug":"MQ","permalink":"https://blog.kurenai.moe/tags/MQ/"},{"name":"Micro Service","slug":"Micro-Service","permalink":"https://blog.kurenai.moe/tags/Micro-Service/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.kurenai.moe/tags/Redis/"}]},{"title":"Redis笔记01","slug":"redis-note-01","date":"2021-03-24T09:18:07.000Z","updated":"2021-05-17T02:48:36.000Z","comments":true,"path":"2021/03/24/redis-note-01/","permalink":"https://blog.kurenai.moe/2021/03/24/redis-note-01/","excerpt":"使用Redis时有时候会碰上一些并发的问题，这里来说一下分布式锁以及加锁超时等问题。","text":"使用Redis时有时候会碰上一些并发的问题，这里来说一下分布式锁以及加锁超时等问题。 封面一天在某神社（？）看到的。非常向往这种中世纪风格，可能是因为《狼与香辛料》或者大多那种剑与魔法的世界，都在这样的时代吧，让我觉得特别浪漫。 0x00一般情况下，会对那些变化不大但是访问量比较大的请求做缓存处理，但缓存会在某个时刻失效，此时就会有大量的请求涌向数据库从而容易引发雪崩效果。 0x01为了避免雪崩，我们可以在更新缓存的代码块（即访问数据库）中加入分布式锁，只能够让一个线程去做缓存更新: 1234if (redis.setIfAbsent(lock, 1)) &#123; // 更新缓存逻辑 redis.del(lock);&#125; 但是上面如果更新逻辑出现卡死现象就会造成死锁，所以我们还需要给锁设置超时时间，但是设置超时时间一般的工具例如spring的RedisTemplate是没有把检查存在并设置值和设置超时时间作为一个请求发送的，则无法保证是原子操作，这样也会发生在设置超时时间的时候没有成功导致死锁。 由于redis新版本支持了setNX和EX复合指令的原子操作（即判断存在和设置超时时间），所以我们可以去扩展RedisTemplate或者当前使用的工具类；另一种方法则是用lua脚本，执行lua脚本也是一次原子操作。 redis在4.0之前整体都是单线程的，4.0后开始加入多线程，但也仅是部分操作，所以就算非复合指令也可以通过一个请求发送多个指令的方式来达成原子操作的目的。 1234if (redis.setAndExpireIfAbsent(lock, 1, 10000)) &#123; // 更新缓存逻辑 redis.del(lock);&#125; 注意redis 2.6.12 之前，set返回永远为ok，之后则设置成功时返回ok，加入条件参数不成立则返回空 0x02但我们可能还会发现另一个问题，更新逻辑太久了超过了超时时间，此时锁已经被解除了，这就会执行导致途中另一个线程获取到了锁，导致后面删除的时候是删除的另一个线程加的锁。 所以我们需要引入一个随机id，作为当前线程加锁的标识，若后面发现不是相同id则不做删除。 1234567long random = SnowFlakeGenerator.getInstant().nextId();if (redis.setAndExpireIfAbsent(lock, random, 10000)) &#123; // 更新缓存逻辑 if (redis.get(lock) == random) &#123; redis.del(lock); &#125;&#125; Ok，到了这里你可能也发现了，这个删除是不是也要做原子操作比较好点(没错…若是不做原子操作，那可能就会虽然拿到锁的值能够匹配上，但是下一个瞬间就因为超时而被别的其他线程获取到锁从而又引发了上面的问题，删错了别的线程的锁。 0x03类似的由于超时导致的问题还有一些情况就是计数器 12345678910111213synchronized (LOCK) &#123; //只是为了排除多线程情况，这里只想讨论超时问题，实际情况还要具体分析 if(redis.exists(userId)) &#123; redis.incr(); if (redis.get(userId) &gt; maxAllowedTimes) &#123; return false; &#125; return true; &#125; else &#123; redis.set(userId, 1); redis.setExpire(60000); return ture; &#125;&#125; 上面是一段限制用户一分钟内可访问次数的redis计数器。这里面如果判断到存在后的下一个瞬间恰好超时，此时incr方法在redis的行为就是先创建并设置值为0，然后加1，而没有设置过期时间。导致后面永远被限制访问。 1234567891011121314151617synchronized (LOCK) &#123; if(redis.exists(userId)) &#123; long count = (long) redis.incr(userId); if(redis.ttl(userId) == -1) &#123; redis.setExpire(60000); &#125; if (count &gt; maxAllowedTimes) &#123; return false; &#125; return true; &#125; else &#123; redis.setEx(userId, 60000, 1);//设置1并设置超时时间60000 return ture; &#125;&#125; ttl-2 表示key不存在-1 表示key存在但是没有过期时间 另外一种解决办法就是取当前时间(或者是减去某个时间后)的秒数，然后再去除以60(时间周期)，这样就能够获的一个周期数(第几个周期)，将其拼接在key上，则能够避免删错或者是没有设置超时时间的问题了。 123456789101112131415synchronized (LOCK) &#123; long times = time.times()//假设这是获取当前时间秒数的工具类 // COUNTER_INTERVAL 时间周期 String key = &quot;ACCESS_COUNT:&quot; + times/COUNTER_INTERVAL + &quot;:&quot; + userId if(redis.exists(key)) &#123; long count = (long) redis.incr(key); if (count &gt; maxAllowedTimes) &#123; return false; &#125; return true; &#125; else &#123; redis.setEx(key, 60000, 1);//设置1并设置超时时间60000 return ture; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"https://blog.kurenai.moe/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"ウマ娘手帳","slug":"uma-musume-note","date":"2021-03-10T09:18:07.000Z","updated":"2021-08-25T03:12:45.000Z","comments":true,"path":"2021/03/10/uma-musume-note/","permalink":"https://blog.kurenai.moe/2021/03/10/uma-musume-note/","excerpt":"记录一下玩马娘的心得(已弃坑)","text":"记录一下玩马娘的心得(已弃坑) 属性在培训中，初期一般方针就是刷好感度，找人多的刷，属性一般也是水桶比较稳，直到出道战可能就会稍微改变一下。 スタミナ(耐力)首先属性里面耐力应该是比较关键的，如果耐力不足以跑完则会根据根性降低速度， 典型的就像ダイワスカレと(大和红骥)，快到中期有一个2400m的中距离比赛，看攻略网站是要达到230才会比较安定，如果达不到基本就在最后被甩开了(btw，攻略提到有马的2500m要上到350才比较安定)下面是一些估计值但跟上面看到的攻略不太一样1234短距离 1200 200+マイル 1400-1800 250 ~ 300中距离 2000-2400 300 ~ 400长距离 2500-3200-3600 400 ~ 500+ 固定技能升级 2月初是6W粉丝 4月初是7W粉丝+理事长好感3格 12月底是12W粉丝","categories":[{"name":"Game","slug":"Game","permalink":"https://blog.kurenai.moe/categories/Game/"}],"tags":[{"name":"ウマ娘","slug":"ウマ娘","permalink":"https://blog.kurenai.moe/tags/%E3%82%A6%E3%83%9E%E5%A8%98/"}]},{"title":"Over the wall","slug":"over-the-wall","date":"2020-12-07T01:48:13.000Z","updated":"2021-03-24T09:45:33.000Z","comments":false,"path":"2020/12/07/over-the-wall/","permalink":"https://blog.kurenai.moe/2020/12/07/over-the-wall/","excerpt":"I will record here some information or opinions that I believe.Everything is selected based on my subjective judgment.","text":"I will record here some information or opinions that I believe.Everything is selected based on my subjective judgment. 封面 我的头像出处，《Lian》当中的女主铃音，头像以及本封面都是碟子附赠的图片。片子非常意识流，那种感觉就像第一次看 eva 一样，有点跟不上节奏，或者说觉得非常混沌。 Link 首先，把移民和工作分开：很多人移民了还是要辛苦工作其次，把移民和 “改变命运” 这件事分开：很多人移民了并没有太大的改命然后，把移民和与众不同这件事分开：很多比你条件差的人也成功了然后，把移民和鹤立鸡群这件事分开：即使你移民成功了别人也未必羡慕然后，把移民和生活中任何一件事联系起来：它就像任何一次部门间的工作调动一样平常，组织捞人 捞到你了，组织说让你去海外你就去了，就完事了（和你的个人素质并无关系：比你的英文水平好很多的人，其实也没移民；比你 IT 能力再高的人，其实也没移民；怎么就论到你移民了呢？是的，就是轮到你了。） 并不高不可攀，甚至就像喝水 然后，你会发现 V2EX 其实并不是一个特别适合讨论移民这件事的 BBS，尤其是在增强移民信心和让移民可行性落地的方面：盖因它无法像讨论一件普普通通的事情一样讨论移民，它没这心胸。 Link 不想反驳一些人的观点，毕竟每个人都有表达自己观点的权利。 但是，作为一个个体，你需要明确： 1 、你的一辈子很短，你必须优先考虑眼前的幸福，而不是未来潜在的幸福。比如，我承认中国在改善、在发展，但是在可见的未来几十年，许多问题依然不会得到解决（ e.g.建立独立的司法体系、健全对弱势群体的保护）。这是一个价值观选择题：你选择去伟大地建设这个国家，还是优先保护自己和家人？很遗憾，我比较自私，我也不是伟人，我选择短期内更能保护我个人利益（ e.g.有健全的劳动法、有工会、可以自由访问互联网并且自由交流思想）的地方。 2 、国家是一个政治概念，是一个“协议”、“合同”，而不是一种与生俱来的强加于个体的道德义务。有兴趣的可以参考这里的讨论： https://www.zhihu.com/question/48440859 。所以，不要被这种政治概念和集体思想绑架，否则你就是韭菜——或者你是站在有资源的那一边，可以利用这个概念去绑架别人、割别人韭菜。 3 、移民与否，取决于你在哪里更有优势、能活得更好。我认识的大部分回国的同学，都是在国内非富即贵的。我想了想，似乎非常合理：因为他们回去可以轻而易举地活得很好甚至随意割别人韭菜。如果你也是有本事割别人韭菜的，那就留在国内，毕竟国内机会比较多。但是如果你不属于这种，那么就想想你最在乎什么（ e.g.钱？健康？生活丰富度？稳定性？冒险刺激？相对公平的允许你靠自身努力上升的发展平台？）、如果去国外你是不是可以活得更开心（ e.g.哪些地方可以提供你在乎的这些东西）？ 没有一个国家是完美的，日韩、欧洲、美国、新加坡都有各自的问题（日韩-经济并不是很好、并不是未来的主流市场、发展上限较低；欧洲-经济也不是特别好，除了德国英国稍微好点；美国-在太平洋两岸两位书记的联手协作下，民粹主义盛行；新加坡-主要产业为金融服务业，没有太多 tech 行业的机会）。如果你想追求刺激、追求暴富，那么可能中国更适合你。 但是国内也有国内的问题——e.g.摘取 11 例器官判 2 年 4 个月，写小黄书判 10 年半； 996 是常态；弱势群体随时有可能被“集体”绑架和以“维护集体利益”的名义牺牲。坦白说，中国虽然近年经济发展迅速，但是在对国民个体的保护上与西方国家还差着一整个“文艺复兴”（西方所有价值观的基础——“以人为本、破除神权”）。如果你觉得自己是一个弱势群体，那么可能中国对你来说就是 hard 模式。 最后，再次非常诚恳地建议很多和我一样的“弱势群体”，不要被别人割了韭菜，还帮着人家吆喝。保护好自己和家人、健康快乐地过好自己短暂的一生，这才是最重要的、这也是作为一个人的基本天性和权利—— [身为韭菜，不要自己给自己画饼] 。 Link 另外关于移民途径，似乎现在还是挺多的——人口减少是许多发达国家面临的巨大挑战，所以只要你年轻还是有很多机会的。全球发达国家中似乎只有美国是移民非常难的。 1 、加拿大——读书、拿工作签、枫叶卡；甚至如果不去加拿大读书和工作也可以直接申请枫叶卡，只要你打分足够——年纪轻加分、高学历加分、工作经验加分（自行搜索加拿大移民 Express Entry 打分系统）；2 、新加坡——只要能找到工作就能申请到工作签和之后申请绿卡，没有名额限制。位于新加坡的 tech 公司虽然不多，但还是有几家，之前在 v 站也看到过相关的招人贴，请自行搜索；3 、欧洲——只要能找到工作，就能申请到工作签并且之后申请绿卡，无名额限制。但是直接找欧洲工作比较难找，因为欧洲人自己找工作本身就比较难了（尤其是英国，暂且还是把英国算在欧洲吧 lol ）。加入国际公司再申请内部 relocation 的思路比较有实操意义，前提是你能说服老板为什么要 relocate 。要么就还是读书、工作签、申请绿卡，也不是很难。4 、美国——除非能直接找到工作并且申请到 H1B，或者加入在华美国公司一年后以 L1 签证调来美国；要么就是读书、找工作、申请 H1B 、申请绿卡；要么就是投资移民、结婚移民等途径了。5 、日韩——不清楚，按理说也不会很难。 途径还是一直有的，就看你愿不愿意冒险和花成本了。经济上，我之前也见过许多国际学生贷款来读书的——可能国内觉得不可思议，但是美国挺常见的，如果你读 MBA 或者 JD 或者 STEM 这种未来赚钱能力强的学位，无需美国人担保即可贷款，请自行搜索 Prodigy Finance 。学校申请上，你如果是为了找工作，未必一定要申请顶尖名校，找工作够用就行。 所以，加油！","categories":[],"tags":[]},{"title":"学习JPA笔记——构建复杂查询","slug":"learning-jpa-02","date":"2020-10-06T09:25:19.000Z","updated":"2021-05-17T02:48:36.000Z","comments":true,"path":"2020/10/06/learning-jpa-02/","permalink":"https://blog.kurenai.moe/2020/10/06/learning-jpa-02/","excerpt":"本篇介绍两种 JPA 做复杂查询的方法，一个是用 SpringDataJPA 实现， 一个是用 Java EE 实现。","text":"本篇介绍两种 JPA 做复杂查询的方法，一个是用 SpringDataJPA 实现， 一个是用 Java EE 实现。 封面：同上篇，这次前景就是最高机密 Viper Zero。嗯，没啥问题，每集一张，只是PS了 ForewordJPA以及其他类似东西之间的关系在进入正题之前还是稍微提一下这几个东西之间的关系。首先JPA是一种规范，Java EE 中有把这种规范抽象出来的接口，具体实现是看用的什么框架，可以是 Hibernate 或者是 EclipseLink 等。而这之中 Spring 又对 Java EE 中的接口再次封装，以更好地整合进 Spring 体系当中，但 SpringDataJPA 仍然是个抽象，具体实现仍然是看选型的框架。但日常中，由于 SpringDataJPA 默认是 Hibernate 实现，所以一般场合基本相当于 Hibernate。 个人对于数据库复杂查询的理解或看法对于联表这些事情我个人的感受来说是极为痛苦的，表面上可以不多此查询数据库，不查询多余数据，不需要程序做多次遍历。其实在一些压力不大的场景中，这些都显得很无所谓。多次连接有缓存，多次遍历实际消耗也不大，多余数据实际上做 join 的时候就会拿过来，join 中加入条件也和第二次查询加入条件差不多。但实际上最麻烦的，是当真正数据库压力上来了，这些操作都没有太大意义，最后还是会在数据库和程序此之间加入缓存，把数据库做的很多事情放到程序当中去做，尽量减低数据库压力。而此时你就会发现之前做的联表查询之类的就像是外来物一样格格不入。 所以我对此也非常欣赏DDD的设计美感。 SpringDataJPASpringDataJPA 的复杂查询除了直接写 sql，按照规则定义 Repository 接口方法以外，还可以使用Specification做查询。 Specification这是SpringDataJPA抽象出的一个接口，故并不一定通用于其他JPA的实现。该接口重点在于toPredicate方法，该方法将创建一个 where 语句对象。 1234567891011public interface Specification&lt;T&gt; extends Serializable &#123; ... /** * Creates a WHERE clause for a query of the referenced entity in form of a Predicate for the given * Root and CriteriaQuery. */ @Nullable Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder);&#125; 这里我只做简要说明，以便于理解，仅供参考。 root： 一般指实体类本身，包装成 Root 对象, 可由query.from(Post.class)得到Root&lt;Post&gt;，Java EE 会提到。 query： sql语句对象，一般在此方法内部不做调用，Java EE 会给一些用于理解的调用。 criteriaBuilder： 用于构建条件语句。 个人建议是不要管我说的这些，真要去理解就看源码注释，或者看下面 Java EE 的代码，更能够理解。 Getting Started首先我们创建一个 Repository 接口，并继承JpaSpecificationExecutor&lt;T&gt;以获得复杂查询的能力。 12public interface PostRepository extends JpaSpecificationExecutor&lt;Post&gt; &#123;&#125; 然后我们运用 java8 所带来的新特性，使用 lambda 构建一个匿名 Specification 的实现类，并实现 toPredicate 方法。 12345678910repository.findAll( (Specification&lt;Post&gt;) (root, criteriaQuery, builder) -&gt; &#123; // where title like &#x27;%Test%&#x27;; return builder.like(root.get(Post_.title), &quot;%Test%&quot;) // 如果是多个条件，例如 where title like &#x27;%Test%&#x27; and content like &#x27;%Test%&#x27; and id &lt; 10; return builder.and(builder.like(root.get(Post_.title), &quot;%Test%&quot;), builder.like(root.get(Post_.content), &quot;%Test%&quot;), builder.le(root.get(Post_.id), 10)) // 而如果我们没有做 Typesafe，那么就会变成这样 return builder.like(root.get(&quot;title&quot;), &quot;%Test%&quot;) &#125;); 使用起来其实没什么困难，基本举一反三，其他的复杂查询我暂时没研究，主要是觉得可以避开用别的方法操作，或者提到程序中操作。 Java EE实际上，SpringDataJPA 是对 Java EE 原本的 JPA 抽象再次包装了一层，所以这个可以说是原汁原味了。 Getting Stated由于我主要使用 SpringDataJPA 所以摘抄了一段代码，出处。 123456789101112131415161718192021222324252627//需要对此进行注入private final EntityManage entityManager;String q;int offset, limit;CriteriaBuilder cb = this.entityManager.getCriteriaBuilder();// create queryCriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class);// set the root classRoot&lt;Post&gt; root = query.from(Post.class);// if keyword is providedif (q != null &amp;&amp; !q.trim().isEmpty()) &#123; // 这里其实就是上面 toPredicate 返回的对象作为参数传入where方法当中，所以里面就和上面的实现没有什么太大区别。 query.where( cb.or( cb.like(root.get(Post_.title), &quot;%&quot; + q + &quot;%&quot;), cb.like(root.get(Post_.content), &quot;%&quot; + q + &quot;%&quot;) ) );&#125;//perform queryreturn this.entityManager.createQuery(query) .setFirstResult(offset) .setMaxResults(limit) .getResultList(); EntityManager 实体管理类，用于与持久化上下文进行互动，核心类。 其他几个 Root、CriteriaQuery、CriteriaBuilder 作用同上，毕竟spring只是做了封装。看完上面代码，大致就能够了解清楚这几个类分别是怎么使用的了，总体来说其实比上面spring的实现所接触到的东西更加全面一些，也能够理解这几个类互相是怎么作用的了。 Referencehelidon-sample @ hantsy","categories":[{"name":"编程","slug":"编程","permalink":"https://blog.kurenai.moe/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.kurenai.moe/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"https://blog.kurenai.moe/tags/JPA/"},{"name":"ORM","slug":"ORM","permalink":"https://blog.kurenai.moe/tags/ORM/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://blog.kurenai.moe/tags/Hibernate/"}]},{"title":"学习JPA笔记——使用MetaModel实现Typesafe","slug":"learning-jpa-01","date":"2020-10-06T07:25:51.000Z","updated":"2021-05-17T02:48:36.000Z","comments":true,"path":"2020/10/06/learning-jpa-01/","permalink":"https://blog.kurenai.moe/2020/10/06/learning-jpa-01/","excerpt":"本篇主要说 Typesafe，下一篇讲一下 JPA 构建复杂查询。项目极简代码在这","text":"本篇主要说 Typesafe，下一篇讲一下 JPA 构建复杂查询。项目极简代码在这 封面：动画「ガーリー・エアフォース」#08的 EDCard，算是原作插画师@遠坂あさぎ的贺图，每集一张。有趣的是因为最高机密的特性导致男主看到的样子和幼馴染一样，而此时他的幼馴染正生着气，所以标题叫不高兴的最高机密w 最近看了@hantsy大大在V站的帖子（这里、这里），就开始心血来潮想要看看 JPA 怎么玩，另外就是大大所说的 Typesafe 要这么实现。 注意：这里不会对JPA大多的基础知识进行说明，文章本意是做一次笔记，必要时请充分发挥自主能动性进行查找学习 Typesafe我的理解是不要那种无法编译时无法检验出错误或者 IDE 无法帮助我们检验错误的字符串，而这里比较突出的就是字段名。 我司其实也是内部写了一套 orm，只是基本不在意 Typesafe，而更加注重方便直接编写复杂 sql 而已。 而没有编译时的检测或者是 IDE 的检测，就难免出现 Typo，更加糟糕的是后期维护时的修改会造成一种我还有哪里用到了这个字段的尴尬状况，一旦遗漏就只能等运行时才可以检测出了。 为了解决这一状况，我们可以用到 MetaModel 生成器，例如 Hibernate 就有相应的生成器jpamodelgen（这类 MetaModel 生成器是为了实现 JPA2.0 标准的，具体我没有细查） 除了 Hibernate 以外，EclipseLink 也有这类生成器，各位可以自己去玩玩。我由于直接用 SpringDataJpa，而 spring 默认使用 Hibernate，所以就没有折腾别的了。 Getting Started下面是我整合了Lombok生成器的配置，仅供参考。也可以看看这篇文章，有多种玩法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;project&gt; ... &lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;version&gt;5.4.21.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 如果不是用SpringDataJpa的话，需要额外引入下面的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt; &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ... &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths &gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.bsc.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-processor-plugin&lt;/artifactId&gt; &lt;version&gt;4.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;process&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;configuration&gt; &lt;processors&gt; &lt;processor&gt;org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor&lt;/processor&gt; &lt;/processors&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;version&gt;5.4.21.Final&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 添加完后，在实体类添加@Entity和@Id的注解使生成器生效，例如： 1234567891011121314151617181920212223242526@Entity@Datapublic class Post implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) int id; String title; String content; @Enumerated(EnumType.STRING) Status status = Status.DRAFT; LocalDateTime createdAt; @Transient String excludeColumn; static enum Status&#123;DRAFT, PUBLISHED&#125; public static Post of(String title, String content) &#123; Post post = new Post(); post.setCreatedAt(LocalDateTime.now()); post.setTitle(title); post.setContent(content); return post; &#125;&#125; 添加完后对代码进行编译，生成器则会找到该注解的类生成这样的类： 1234567891011121314151617@Generated(value = &quot;org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor&quot;)@StaticMetamodel(Post.class)public abstract class Post_ &#123; public static volatile SingularAttribute&lt;Post, LocalDateTime&gt; createdAt; public static volatile SingularAttribute&lt;Post, Integer&gt; id; public static volatile SingularAttribute&lt;Post, String&gt; title; public static volatile SingularAttribute&lt;Post, String&gt; content; public static volatile SingularAttribute&lt;Post, Status&gt; status; public static final String CREATED_AT = &quot;createdAt&quot;; public static final String ID = &quot;id&quot;; public static final String TITLE = &quot;title&quot;; public static final String CONTENT = &quot;content&quot;; public static final String STATUS = &quot;status&quot;;&#125; 而当我们运行程序时，SingularAttribute 类型的对象则会被自动赋值，之后在调用 JPA 的 API 时则可以作为参数传入，而不是传入字符串了。调用时看起来是这样子的： 1repository.findAll((Specification&lt;Post&gt;) (root, criteriaQuery, builder) -&gt; builder.like(root.get(Post_.title), &quot;%Test%&quot;)) 我说什么来着，不用字符串其实这里就不太需要追求这些，而字段这些是带关联性的，会在好多个地方出现，有必要对其进行检测。对于人类而言，检测总是会犯错，所以这些最好是交由机器来帮忙，也能够让我们更加关注业务。 Referencehelidon-sample @ hantsyHibernate JPA 2 Metamodel Generator","categories":[{"name":"编程","slug":"编程","permalink":"https://blog.kurenai.moe/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.kurenai.moe/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"https://blog.kurenai.moe/tags/JPA/"},{"name":"ORM","slug":"ORM","permalink":"https://blog.kurenai.moe/tags/ORM/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://blog.kurenai.moe/tags/Hibernate/"}]},{"title":"Reactor中的上下文","slug":"context-of-reactor","date":"2020-09-08T22:53:22.000Z","updated":"2020-10-06T04:51:51.000Z","comments":true,"path":"2020/09/08/context-of-reactor/","permalink":"https://blog.kurenai.moe/2020/09/08/context-of-reactor/","excerpt":"由于参与的项目当中决定用 spring-cloud-gateway 作为网关，所以自然就碰上了Reactor当中获取上下文的问题。 这里我是遇到了 I18N 需要获取上下文中 Locale 的问题，所以我就以这个问题举例，提供其中一种上下文的解决方法。","text":"由于参与的项目当中决定用 spring-cloud-gateway 作为网关，所以自然就碰上了Reactor当中获取上下文的问题。 这里我是遇到了 I18N 需要获取上下文中 Locale 的问题，所以我就以这个问题举例，提供其中一种上下文的解决方法。 What happened在使用 I18N 进行国际化时，Servlet 框架下我们通常会使用 ThreadLocal 进行储存解析请求得到上下文的 Locale 对象，以判断当前请求需要的是什么语言。但在 Reactor 框架下，由于一个请求整个流程下来，线程都在不断的进行切换，所以 ThreadLocal 自然也就失去上下文储存对象的能力。 经过简单的谷歌查询，我只能想两种处理方法： 从 controller 获取 Locale 或者任意能够得到 Exchange（类似 Request）的方法开始一路传递下去。 直接将 I18N 的 key 传入自定义异常对象当中，然后在统一异常处理类当中获取 Exchange 再做进一步的国际化操作。 但他们都不够优雅，而且其中弊端也很明显，一个是需要无限传递变量，一个是只能限制再异常处理类进行处理，理所当然就无法添加国际化的变量。 How should I do如何取值令人喜悦的是，Spring 其实已经写了一个获取上下文的例子了，它就是ReactiveSecurityContextHolder，对应 Servlet 当中的SecurityContextHolder。 ReactiveSecurityContextHolder#getContext 1234567private static final Class&lt;?&gt; SECURITY_CONTEXT_KEY = SecurityContext.class;public static Mono&lt;SecurityContext&gt; getContext() &#123; return Mono.subscriberContext() .filter( c -&gt; c.hasKey(SECURITY_CONTEXT_KEY)) .flatMap( c-&gt; c.&lt;Mono&lt;SecurityContext&gt;&gt;get(SECURITY_CONTEXT_KEY));&#125; 可以看到，通过Mono.subscriberContext()，我们可以得到一个上下文对象，然后他先判断是否包含给出的key值，包含则获取值。这里需要注意，如果直接获取值会抛出异常。 如何赋值当我查看withSecurityContext方法时，其注释告诉我是用来创建一个包含SecurityContext的 Reactor 上下文对象（Context）并可被用于与其他上下文对象（Context）进行合并。 所以当我们查看有什么方法调用它时，就会发现ReactorContextWebFilter这个过滤器。 123456789101112131415161718192021public class ReactorContextWebFilter implements WebFilter &#123; private final ServerSecurityContextRepository repository; public ReactorContextWebFilter(ServerSecurityContextRepository repository) &#123; Assert.notNull(repository, &quot;repository cannot be null&quot;); this.repository = repository; &#125; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123; return chain.filter(exchange) .subscriberContext(c -&gt; c.hasKey(SecurityContext.class) ? c : withSecurityContext(c, exchange) ); &#125; private Context withSecurityContext(Context mainContext, ServerWebExchange exchange) &#123; return mainContext.putAll(this.repository.load(exchange) .as(ReactiveSecurityContextHolder::withSecurityContext)); &#125;&#125; ServerSecurityContextRepository#load 12345678public Mono&lt;SecurityContext&gt; load(ServerWebExchange exchange) &#123; return exchange.getSession() .map(WebSession::getAttributes) .flatMap( attrs -&gt; &#123; SecurityContext context = (SecurityContext) attrs.get(this.springSecurityContextAttrName); return Mono.justOrEmpty(context); &#125;);&#125; ReactiveSecurityContextHolder#withSecurityContext 123public static Context withSecurityContext(Mono&lt;? extends SecurityContext&gt; securityContext) &#123; return Context.of(SECURITY_CONTEXT_KEY, securityContext);&#125; 通过阅读上面的代码可得知，上面的过滤器通过ServerSecurityContextRepository解析请求中的 Security 上下文，通过ReactiveSecurityContextHolder生成 Securtiy 上下文对象并返回。 Finally我们可以仿照着写一个从请求对象当中解析出一个 Locale 对象并放入上下文当中（不确定是不是上下文，但是Reactor确实是用这种办法实现了上下文的功能）。 12345678910111213141516171819202122// 将 Locale 放到上下文中public class ReactorLocaleContextWebFilter implements WebFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123; return chain.filter(exchange) .subscriberContext(c -&gt; c.hasKey(Locale.class) ? c : withLocaleContext(c, exchange) ); &#125; private Context withLocaleContext(Context mainContext, ServerWebExchange exchange) &#123; //解析请求获取 Locale Locale locale = getLocale(exchcange); return mainContext.putAll(Context.of(Locale.class, Mono.justOrEmpty(locale))); &#125;&#125;//获取 LocaleMono.subscriberContext() .filter( c -&gt; c.hasKey(Locale.class)) .flatMap( c-&gt; c.&lt;Mono&lt;Locale&gt;&gt;get(Locale.class)); 具体实现我日后会写一个demo。咕咕咕","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.kurenai.moe/categories/Java/"},{"name":"Reactor","slug":"Java/Reactor","permalink":"https://blog.kurenai.moe/categories/Java/Reactor/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.kurenai.moe/tags/Java/"},{"name":"Reactor","slug":"Reactor","permalink":"https://blog.kurenai.moe/tags/Reactor/"},{"name":"Webflux","slug":"Webflux","permalink":"https://blog.kurenai.moe/tags/Webflux/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.kurenai.moe/tags/Spring/"}]},{"title":"Reactor处理阻塞问题笔记","slug":"lean-pulishOn-of-reactor","date":"2020-03-03T09:53:22.000Z","updated":"2021-05-17T02:48:36.000Z","comments":true,"path":"2020/03/03/lean-pulishOn-of-reactor/","permalink":"https://blog.kurenai.moe/2020/03/03/lean-pulishOn-of-reactor/","excerpt":"其实本来想要记录问题的过程，但奈何自己也说不太好XD","text":"其实本来想要记录问题的过程，但奈何自己也说不太好XD What由于接触Vert.x以及阅读其文档后，了解到异步编程下是不能够阻塞主线程的，不然异步将失去意义。 我们需要做的是将这些阻塞线程移到其他线程进行处理。 How利用Mono或是Flux的PublishOn方法将之后调用的方法都移动到其他线程进行处理。 publishOn 12public final Mono&lt;T&gt; publishOn(Scheduler scheduler);public final Flux&lt;T&gt; publishOn(Scheduler scheduler); 其中Scheduler可用Schedulers.parallel()或Schedulers.single()进项创建或是其他方法，其中single和parallel是有一些区别的。 single 这一条调用链下不会同时执行，并且只有这条调用链执行完成后才会再次被调用 parallel 与上面相反，调用链会在同时执行 下面是测试代码 本人只是刚开始玩reactor，程序写的很蹩脚XD 12345678910111213141516171819202122232425262728293031323334353637383940414243@Test public void test() throws IOException &#123; AtomicReference&lt;Employee&gt; employeeAR = new AtomicReference&lt;&gt;(); //&lt;1&gt; Scheduler scheduler = Schedulers.single(); //&lt;2&gt; for (int i = 0; i &lt; 5; i++) &#123; int finalI = i; Mono.just(1) .publishOn(scheduler) .map(x -&gt; &#123; try &#123; Thread.sleep(1000); System.out.println(finalI + &quot;-&quot; + Thread.currentThread() .getName() + &quot;-A&quot;); //&lt;3&gt; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Employee emp = buildEmployee(); employeeAR.set(emp); //&lt;1&gt; return emp; &#125;) .map(x -&gt; &#123; try &#123; System.out.println(finalI + &quot;-&quot; + Thread.currentThread() .getName() + &quot;-B&quot;); //&lt;3&gt; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return x; &#125;) .map(x -&gt; &#123; System.out.println(finalI + &quot;-&quot; + Thread.currentThread() .getName() + &quot;-C&quot;); //&lt;3&gt; return employeeAR.get().getAccountId(); //&lt;1&gt; &#125;) .subscribe(System.out::println); System.out.println(Thread.currentThread() .getName()); //&lt;3&gt; &#125; char c = (char) System.in.read(); System.out.println(&quot;your char is: &quot; + c); &#125; &lt;1&gt; 因为涉及到匿名方法中的变量的再次调用，所以用到AtomicReference进行储存。 下面是single的运行结果 12345678910111213141516171819202122232425mainmainmainmainmain0-single-1-A0-single-1-B0-single-1-C1231-single-1-A1-single-1-B1-single-1-C1232-single-1-A2-single-1-B2-single-1-C1233-single-1-A3-single-1-B3-single-1-C1234-single-1-A4-single-1-B4-single-1-C123 将&lt;2&gt;中single改为parallel 12345678910111213141516171819202122232425mainmainmainmainmain0-parallel-1-A3-parallel-4-A2-parallel-3-A4-parallel-5-A0-parallel-1-B3-parallel-4-B2-parallel-3-B1-parallel-2-A1-parallel-2-B4-parallel-5-B0-parallel-1-C1-parallel-2-C3-parallel-4-C4-parallel-5-C2-parallel-3-C123123123123123 观察代码中&lt;3&gt;，我们可以发现调用链当中是按照顺序执行的（我最开始以为会平行执行调用链中的方法，但并不是），而且主线程也没有被阻塞，能够快速输出当前线程名称，由此可见已经达到我们最初的目的了——不阻塞主线程。 Why在这里我用的是Spring WebFlux，而其中会用到netty，其中有一个Eventloop模块，这是由单个线程运行的模块，这个单线程就是由我们程序所运行的主线程来担当。 Eventloop会重复检查当前有没有事件产生，若有则会接收该事件并运行相应的事件响应，也就是发布订阅模式，而如果我们在其中一个调用该事件的响应方法中等待（阻塞）过久，就会导致我们无法快速处理后续产生的事件，只能够加多线程进行快速处理，这就又回到了非异步编程当中去了。 所以能够快速响应才能够体现出异步编程的优势。 Reference Is there a standard way to solve blocking that must happen. How to handle blocking calls when using reactor in a JAX-RS-powered server? TODO 测试嵌套调用publishiOn是什么情况 是否是调用一次publishOn后，后面的链式调用都是在另一条线程，是否需要再次调用一次pubulishOn保证之后的一次阻塞操作也不在主线程当中 补充详细Evenloop 寻找更加优雅的方式，或者看看这种链式调用是不是也是一个不太好的地方","categories":[{"name":"编程","slug":"编程","permalink":"https://blog.kurenai.moe/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.kurenai.moe/tags/Java/"},{"name":"Reactor","slug":"Reactor","permalink":"https://blog.kurenai.moe/tags/Reactor/"},{"name":"Webflux","slug":"Webflux","permalink":"https://blog.kurenai.moe/tags/Webflux/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.kurenai.moe/tags/Spring/"}]},{"title":"Re：从零开始的领域驱动设计","slug":"DDD","date":"2019-08-11T00:00:00.000Z","updated":"2020-07-06T12:36:52.000Z","comments":true,"path":"2019/08/11/DDD/","permalink":"https://blog.kurenai.moe/2019/08/11/DDD/","excerpt":"领域驱动设计(Domain-driven design)，缩写为DDD。以领域设计为驱动，构建整一个系统。 这个设计思想是在微服务开始流行时逐渐变得火爆的，因为其设计理念非常适合分布式的微服务拆分。","text":"领域驱动设计(Domain-driven design)，缩写为DDD。以领域设计为驱动，构建整一个系统。 这个设计思想是在微服务开始流行时逐渐变得火爆的，因为其设计理念非常适合分布式的微服务拆分。 我声明一点，本文章其实都是东拼西凑的，里面所表达的仅仅是个人的理解（我没有读完ddd那本书） 通用语言(Ubiquitous Language)通用语言其实就是把模型通过大家都能够理解的语言表达出来。 通常我们在开发业务的过程中都是先去调研，了解其业务的具体细节，并商讨大致的程序设计，然后经过开发人员转化成为代码，在这个过程中交流是单向性的，直到下一次需要展示或者有理解出现错误时才会与客户或者是业务人员再次交流。 而业务人员那边通常也只能通过表面的程序看问题，无法理解其实际运作是否符合业务人员所想，这可能将导致程序在错误的方向上越走越远 领域驱动设计是需要建立一个通用语言的，这需要领域专家(即对这些业务整体非常熟悉的人)与开发人员一同参与 我们需要把程序设计上的事情通过一个通用的语言表述出去使领域专家能够理解我们是如何通过程序设计业务的，而领域专家也同样需要把那些专业名词，业务场景用通用语言描述出来 当我们有了通用语言后，我们就能够在建立领域对象的时候听取专家的意见，同时能够让专家理解领域对象是否符合他们的预期 而形成通用语言是不容易的，因为其答案并不唯一，不同的人会有不同的理解，从而导致不同的答案。但我们可以试着从UML或是伪代码着手 航运例子 层结构(Layered Architecture) User Interface负责向用户展现信息，并且会解析用户行为，即常说的展现层。 Application Layer应用层没有任何的业务逻辑代码，它很简单，它主要为程序提供任务处理。 Domain Layer这一层包含有关领域的信息，是业务的核心，领域模型的状态都直接或间接（持久化至数据库）存储在这一层。 Infrastructure Layer为其他层提供底层依赖操作。 模型关系图(Model-Driven Design) 服务(Services)当我们在分析某一领域时，一直在尝试如何将信息转化为领域模型，但并非所有的点我们都能用Model来涵盖。对象应当有属性，状态和行为，但有时领域中有一些行为是无法映射到具体的对象中的，我们也不能强行将其放入在某一个模型对象中，而将其单独作为一个方法又没有地方，此时就需要服务 工厂(Factories)在大型系统中，实体和聚合通常是很复杂的，这就导致了很难去通过构造器来创建对象。工厂就决解了这个问题，它把创建对象的细节封装起来，巧妙的实现了依赖反转。当然对聚合也适用（当建立了聚合根时，其他对象可以自动创建） 仓库(Repository)仓库封装了获取对象的逻辑，领域对象无须和底层数据库交互，它只需要从仓库中获取对象即可。仓库可以存储对象的引用，当一个对象被创建后，它可能会被存储到仓库中，那么下次就可以从仓库取。如果用户请求的数据没在仓库中，则会从数据库里取，这就减少了底层交互的次数 边界上下文(Bounded Context)简单来说就是定义该领域模型的适用范围以及使用场景。 可以这样理解： 边界(Bounded)即有边界的，表示领域模型有边界；这个边界定义了模型的适用范围，以便让负责该模型的团队知道什么该在模型中实现，什么不该； 上下文(Context)即领域模型的产生是在某个上下文中产生的；上下文是一个和环境相关的概念。比如一次头脑风暴会议大家达成了一个模型，那这次会议的讨论就是该模型的上下文；比如某本书中谈到了某个东西，那这个东西的上下文就是那本书，那个东西要有意义的前提离不开那本书这个上下文；所以，上下文是模型有意义的前提； 实体(Entity) 和 值对象(ValueObject)一言蔽之，实体大致可以理解为我们传统开发的实体，但是他具有自己的行为，而不是POJO(只具有简单的getter,setter)；值对象是指描述一个实体某个属性的对象。当然，这些都是需要在上面所说的BoundedContext被指定的前提下讨论。 举个例子：在电商系统我们现在分成两个模块，一个商品模块，一个订单模块订单对象中有收货地址(address) 1234class Order &#123; int id; String address; &#125; 我们把address扩展开来 12345678910class Order &#123; int id; Address address; &#125;class Address &#123; String province;//省 String city;//市 String street;//街道&#125; 现在Address是一个对象了，但是我们不会认为他是一个实体，因为在这个订单模块中它只是描述了订单中的收货地址而已，仅仅只是order上的一个值，几个内部的值所组合出的抽象，你完全可以把它理解为是一个Map: 123456class Order &#123; int id; Map&lt;String, String&gt; address; //address Map&#123;&quot;province&quot;:&quot;&quot;,&quot;city&quot;:&quot;&quot;,&quot;street&quot;:&quot;&quot;&#125; &#125; 这跟java中String对象非常类似，String对象是不会进行修改的，如果你将新的一串字符串重新赋值给一个String对象，实际上等于new了一个String，地址是变化了的，不再是同一个对象。 所以ValueObject有这样几个特点: 没有标识(唯一标识) 不可变(只读) 不具备生命周期 聚合(Aggregates) 和 聚合(Aggregate Root)聚合可以看作是多个实体之间的组合，而每个聚合都有一个根实体，叫聚合根。 在DDD当中，聚合外部想要访问聚合内的信息，必须通过聚合根进行访问。 如何识别聚合和聚合根？首先一个边界上下文(Bounded Context)可能包含多个聚合，每个聚合都有一个聚合根。 找出哪些实体可能是聚合根 逐个分析每个聚合根的边界，即该聚合根应该聚合哪些实体或值对象 划分边界上下文 如何确定聚合边界？边界的确定法则是根据不变性约束规则（Invariant）: 聚合边界内必须具有哪些信息，如果没有这些信息就不能称为一个有效的聚合 聚合内的某些对象的状态必须满足某个业务规则 如何找到聚合根？如果存在一个业务操作是完全面向某个实体，那么这个实体就可能是一个聚合根 例子分析 Order（一 个订单）必须有对应的客户信息，否则就不能称为一个有效的Order同理，Order对OrderLineItem有不变性约束，Order也必须至少有一个OrderLineItem(一条订单明细)，否则就不能称为一个有效的Order另外，Order中的任何OrderLineItem的数量都不能为0，否则认为该OrderLineItem是无效的，同时可以推理出Order也可能是无效的。因为如果允许一个OrderLineItem的数量为0的话，就意味着可能会出现所有OrderLineItem的数量都为0，这就导致整个Order的总价为0，这是没有任何意义的，是不允许的，从而导致Order无效所以，必须要求 Order中所有的OrderLineItem的数量都不能为0那么现在可以确定的是Order必须包含一些OrderLineItem，那么应该是通 过引用的方式还是ID关联的方式来表达这种包含关系呢？这就需要引出另外一个问题，那就是先要分析出是OrderLineItem是否是一个独立的聚合根。回答了这个问题，那么根据上面的规则就知道应该用对象引用还是用ID关联了。那么OrderLineItem是否是一个独立的聚合根呢？因为聚合根意 味着是某个聚合的根，而聚合有代表着某个上下文边界，而一个上下文边界又代表着某个独立的业务场景，这个业务场景操作的唯一对象总是该上下文边界内的聚合 根。想到这里，我们就可以想想，有没有什么场景是会绕开订单直接对某个订单明细进行操作的。也就是在这种情况下，我们 是以OrderLineItem为主体，完全是在面向OrderLineItem在做业务操作。有这种业务场景吗？没有，我们对 OrderLineItem的所有的操作都是以Order为出发点，我们总是会面向整个Order在做业务操作，比如向Order中增加明细，修改 Order的某个明细对应的商品的购买数量，从Order中移除某个明细，等等类似操作，我们从来不会从OrderlineItem为出发点去执行一些业 务操作；另外，从生命周期的角度去理解，那么OrderLineItem离开Order没有任何存在的意义，也就是说OrderLineItem的生命周 期是从属于Order的。所以，我们可以很确信的回答，OrderLineItem是一个实体。 Event Souring(事件溯源)Event Souring是Martin Fowler提出的一种架构模式，其特点是： 整个系统由事件进行驱动 事件是一等公民，系统的基础数据是事件，事件需要被储存在数据库中 业务数据只是由事件产生的视图，不一定需要存储在数据库 这里展示的例子是一个银行账户经历的几个事件：创建 -&gt; 存款300 -&gt; 存款100 -&gt; 取出200 在这样的设计下，每个对象都需要经历一系列的事件才会转化成现在的状态，当我们只需要进行查询的时候，这些操作未免显得太过累赘，所以我们可以把对象的最终状态存入一个视图数据库，当需要查询的时候直接查询这个数据库即可 CQRS(命令查询责任分离)CQRS简单理解就是读写分离，但它的实现可能相对其定义要复杂些，并且通常都是会和Event Souring一起被提及 参考资料： 《领域驱动设计：软件核心复杂性应对之道》 深入浅出Event Sourcing和CQRS Re：从零开始的领域驱动设计 一个DDD指导下的实体类设计案例 DDD领域驱动设计基本理论知识总结 多研究些架构，少谈些框架","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.kurenai.moe/categories/Java/"}],"tags":[{"name":"DDD","slug":"DDD","permalink":"https://blog.kurenai.moe/tags/DDD/"},{"name":"CQRS","slug":"CQRS","permalink":"https://blog.kurenai.moe/tags/CQRS/"},{"name":"Event Sourcing","slug":"Event-Sourcing","permalink":"https://blog.kurenai.moe/tags/Event-Sourcing/"},{"name":"Java","slug":"Java","permalink":"https://blog.kurenai.moe/tags/Java/"}]},{"title":"将项目部署在docker中","slug":"将项目部署在docker中","date":"2019-03-14T11:39:00.000Z","updated":"2023-01-06T20:14:19.000Z","comments":true,"path":"2019/03/14/将项目部署在docker中/","permalink":"https://blog.kurenai.moe/2019/03/14/%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8docker%E4%B8%AD/","excerpt":"docker中有两个概念，容器与镜像。 镜像我们可以简单的理解为是装机用的光盘，而容器就是我们用光盘所装的一个系统。实际上我们就是由镜像生成一个容器，一个镜像可以生成多个容器（只要容器互不相冲突）。 而镜像的生成就是由配置文件来决定（配置文件参数可由后期运行指令等等操作更改），具体如何配置不详细说明。","text":"docker中有两个概念，容器与镜像。 镜像我们可以简单的理解为是装机用的光盘，而容器就是我们用光盘所装的一个系统。实际上我们就是由镜像生成一个容器，一个镜像可以生成多个容器（只要容器互不相冲突）。 而镜像的生成就是由配置文件来决定（配置文件参数可由后期运行指令等等操作更改），具体如何配置不详细说明。 Banner: カントク - COLORS 配置文件例子Dockerfile 123456789101112131415161718192021#后端java项目#基础镜像FROM 192.168.1.2:5000/library/centos-jdk:1.7.79#作者MAINTAINER kurenai kurenai@moe.com#执行命令，主要用来安装相关的软件#RUN #添加文件ADD target/supervise-svc-0.0.1-SNAPSHOT.jar /usr/localRUN chmod u+x /usr/local/supervise-svc-0.0.1-SNAPSHOT.jar#挂载目录到容器#VOLUME [&quot;/data&quot;]#环境变量设置#ENV #开放端口EXPOSE 1234#启动时执行的命令CMD [&quot;/bin/bash&quot;]#启动时执行的命令ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;-Xms2048m&quot;, &quot;-Xmx2048m&quot;, &quot;-XX:PermSize=256M&quot;, &quot;-XX:MaxPermSize=256M&quot;,&quot;/usr/local/supervise-svc-0.0.1-SNAPSHOT.jar&quot;] 123456789101112131415161718192021222324#前端react项目#基础镜像FROM xxx.xxx.com:5000/library/ui-nginx:latest#维护人信息MAINTAINER kurenai kurenai@moe.com#工作目录WORKDIR /usr/local/nginxADD ui.tar.gz /usr/local/nginx/html/ADD nginx.conf /usr/local/nginx/conf/#暴露端口EXPOSE 80#连接时执行的命令CMD [&quot;/bin/bash&quot;]#启动时执行的命令#ENTRYPOINT nginx -g &quot;daemon off;&quot;ENTRYPOINT /opt/run.sh 基础命令 123456789docker ps #查看doker中正在运行的容器列表docker images #查看docker中的镜像列表docker build #将当前目录下的文件打包为镜像docker rm #移除容器docker rmi #移除镜像docker pull #拉取镜像docker logs -f #查看日志docker restart #重启容器docker stop #停止容器运行 docker-compose能够比较集中的管理镜像和容器的部署问题，不必用像原生docker那样一个一个项目进行打包镜像生成容器，只需要把n个项目的配置写在配置文件中即可进行批量打包，拉取镜像，生成容器 配置文件例子docker-compose.yml 123456789101112131415161718192021222324252627version: &#x27;2.2&#x27;services: #项目名称，用docker-compose做管理时，每个项目用这里配置的名称进行单独管理 base: #镜像名，拉取镜像时也是用这个名字作为地址 image: 192.168.1.2:5000/test/base-svc:0.0.1-SNAPSHOT #打包路径，即docker build的路径 build: /opt/dockerfile/base-svc restart: always #环境变量 environment: defaultZone: http://192.168.1.3:1200/eureka/ #开放端口 ports: - &quot;1430:1430&quot; #网络连接模式 network_mode: &quot;bridge&quot; supervise: image: 192.168.1.2:5000/test/supervise-svc:0.0.1-SNAPSHOT build: /opt/dockerfile/supervise-svc restart: always environment: defaultZone: http://192.168.1.3:1200/eureka/ ports: - &quot;1570:1570&quot; network_mode: &quot;bridge&quot; 常用命令 123456docker-copmpose build #打包镜像，后面不加项目名则打包所有配置了build的项目，可接多个项目名，用空格隔开docker-compose up -d #后台运行项目，寻找本地镜像生成容器（若镜像更新则重启用新镜像生成容器），或者docker-compose.yml文件改变了也会进行更新容器，同样不接项目名为所有项目，也可以接多个项目名docker-compose logs -f #查看日志，同上可接项目名docker-compose pull #拉取镜像，同上可接项目名docker-compose restart #重启容器，同上docker-compose stop #停止运行容器，同上 实际生产环境部署项目/opt/dockerfile文件夹下是每个项目的目录，每个目录下是一个Dockerfile配置文件+打包的项目文件（java为.jar, react为tar.gz, 视项目和配置文件而定） /opt/cloud目录下是分的几个类，把几个项目归为一起，项目下是docker-compose.yml配置文件 以后端java项目meeting-svc为例 打包项目为jar包， 将jar包放在/opt/dockerfile/meeting-svc目录下 进入到/opt/cloud/service 运行指令docker-compose build meeting(配置文件中配置的项目名为meeting)打包镜像 运行docker-compose up -d meeting更新容器并运行 用docker-compose logs -f meeting进行查看日志 ps： 后端打包为tar -zcvf xxx.tar.gz -C dist/ . #dist为编译文件目录","categories":[{"name":"docker","slug":"docker","permalink":"https://blog.kurenai.moe/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.kurenai.moe/tags/docker/"},{"name":"ops","slug":"ops","permalink":"https://blog.kurenai.moe/tags/ops/"}]},{"title":"Nginx基础——Rewrite规则","slug":"Nginx基础——Rewrite规则","date":"2018-12-30T15:13:00.000Z","updated":"2021-05-17T02:48:36.000Z","comments":true,"path":"2018/12/30/Nginx基础——Rewrite规则/","permalink":"https://blog.kurenai.moe/2018/12/30/Nginx%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Rewrite%E8%A7%84%E5%88%99/","excerpt":"&emsp;&emsp;rewrite是nginx一个特别重要的指令，该指令可以使用正则表达式改写URI。可以指定一个或多个rewrite指令，按顺序匹配。","text":"&emsp;&emsp;rewrite是nginx一个特别重要的指令，该指令可以使用正则表达式改写URI。可以指定一个或多个rewrite指令，按顺序匹配。 正则匹配规则~ 区分大小写匹配* 不区分大小写匹配! 和 !~* 区分大小写不匹配及不区分大小写不匹配 文件及目录匹配-f和!-f 判断是否存在文件-d和!-d 判断是否存在目录-e和!-e 判断是否存在文件或目录-x和!-x 判断文件是否可执行 rewrite基本语法12345set if returnbreakrewrite break指令使用范围：server，location，if; 中断当前相同作用域的其他nginx配置。 if指令使用范围：server，location 检查一个条件是否符合。If指令不支持嵌套，不支持多个条件&amp;&amp;和||处理。 return指令格式：return code ;使用范围：server，location，if; 结束规则的执行并返回状态码给客户端。 set指令使用环境：server，location，if 定义一个变量，并给变量赋值。变量的值可以为文本、变量或者变量的组合。 1set $var &quot;hello world&quot; rewrite指令格式rewrite regex replacement [flag] flag标志位有四种： break：停止rewrite检测,也就是说当含有break flag的rewrite语句被执行时,该语句就是rewrite的最终结果。last：停止rewrite检测,但是跟break有本质的不同,last的语句不一定是最终结果。redirect：返回302临时重定向，一般用于重定向到完整的URL(包含http:部分)permanent：返回301永久重定向，一般用于重定向到完整的URL(包含http:部分) 应用实例当访问的文件和目录不存在时，重定向到某个php文件 1234if( !-e $request_filename )&#123; rewrite ^/(.*)$ index.php last;&#125; 目录对换 /123456/xxxx ====&gt; /xxxx?id=123456 1rewrite ^/(\\d+)/(.+)/ /$2?id=$1 last; 如果客户端使用的是IE浏览器，则重定向到/ie目录下 1234if( $http_user_agent ~ MSIE)&#123; rewrite ^(.*)$ /ie/$1 break;&#125; 禁止访问以/data开头的文件 1234location ~ ^/data&#123; deny all;&#125; 禁止访问以.sh，.flv，.mp3为文件后缀名的文件 1234location ~ .*\\.(sh|flv|mp3)$&#123; return 403;&#125; 设置某些类型文件的浏览器缓存时间 1234location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$&#123; expires 30d;&#125; 文件反盗链并设置过期时间 12345678910111213location ~*^.+\\.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ &#123; valid_referers none blocked *.linuxidc.com*.linuxidc.net localhost 208.97.167.194; if ($invalid_referer) &#123; rewrite ^/ http://img.linuxidc.net/leech.gif; return 412; break; &#125; access_log off; root /opt/lampp/htdocs/web; expires 3d; break;&#125; 将多级目录下的文件转成一个文件，增强seo效果 1234 /job-123-456-789.html 指向/job/123/456/789.htmlrewrite^/job-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ /job/$1/$2/jobshow_$3.html last; 域名跳转 123456789server&#123; listen 80; server_name jump.linuxidc.com; index index.html index.htm index.php; root /opt/lampp/htdocs/www; rewrite ^/ http://www.linuxidc.com/; access_log off;&#125; 多域名转向 123456server_name www.linuxidc.comwww.linuxidc.net;index index.html index.htm index.php;root /opt/lampp/htdocs;if ($host ~ &quot;linuxidc\\.net&quot;) &#123; rewrite ^(.*) http://www.linuxidc.com$1permanent;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"https://blog.kurenai.moe/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.kurenai.moe/tags/Nginx/"},{"name":"转载","slug":"转载","permalink":"https://blog.kurenai.moe/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"とある三秋 缒の摘抄","slug":"とある三秋 缒的一些摘抄","date":"2017-05-20T00:00:00.000Z","updated":"2022-02-20T12:23:16.000Z","comments":true,"path":"2017/05/20/とある三秋 缒的一些摘抄/","permalink":"https://blog.kurenai.moe/2017/05/20/%E3%81%A8%E3%81%82%E3%82%8B%E4%B8%89%E7%A7%8B%20%E7%BC%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%91%98%E6%8A%84/","excerpt":"记录一下比较打动我的一些段落","text":"记录一下比较打动我的一些段落 后记&emsp;&emsp;这世上到处都有地洞，至少世界看在我眼里就是这样。有的洞小，有的洞大；有的洞浅，有的洞深；有的洞很明显，有的洞不明显；有的洞尚有人掉进去，有的洞已经有许多人掉进去。真的是五花八门。一旦想着这一个个地洞，就会让我满心不安，一步都不想动了。&emsp;&emsp;孩提时代，我喜欢那种会让我忘记地洞存在的故事。看来不只是我，大家都喜欢看那种书中世界的所有地洞都已经加盖的故事，也不知道是不是该叫“杀菌过的故事”。当然主角不会只遇到好事，经历的各种痛苦与难受的体验也不会比别人少，但最终来说，这一切都将成为他成长的动力，让读者可以沉浸在“人就是要接受一切勇敢活下去”这种可靠的感觉中。我说的就是这种故事。&emsp;&emsp;我想我们一定是不希望连在虚构的世界都要经历悲伤&emsp;&emsp;可是有一天，我发现自己不知不觉地身在阴暗的地洞中。那是一种没有任何前兆、没有天理可言的失足。由于那是个非常小且不起眼的地洞，很难指望会有别人帮助。所幸这个地洞并不是深到爬不出来，我花了很长时间，靠自己的力量终于脱身。&emsp;&emsp;来到地上后，我沐浴在久违的温暖阳光与清澈的徐风中，因而产生这样的想法。无论多么小心，都没有人知道何时会掉进地洞。这个世界就是这样的地方。下次我说不定会掉进一个更深的洞，深得让我再也回不到地面上。到时候，我该怎么办呢？&emsp;&emsp;从此之后，我就再也无法怀着以往那样单纯的心情，去看待那些“把地洞加了盖的故事”。相对地，我开始喜欢描写“在地洞里过的好像很幸福的人”的故事。因为我想听的是在阴暗、深邃、狭窄又寒冷的地洞里，不用逞强也能露出微笑的人身上所发生的故事。也许对现在的我来说，再也没有什么比这个更能安慰我了。 三秋 缒いたいのいたいの、とんでゆけ","categories":[],"tags":[{"name":"三秋 缒","slug":"三秋-缒","permalink":"https://blog.kurenai.moe/tags/%E4%B8%89%E7%A7%8B-%E7%BC%92/"},{"name":"摘抄","slug":"摘抄","permalink":"https://blog.kurenai.moe/tags/%E6%91%98%E6%8A%84/"},{"name":"小说","slug":"小说","permalink":"https://blog.kurenai.moe/tags/%E5%B0%8F%E8%AF%B4/"}]},{"title":"Test","slug":"Demo","date":"2017-04-20T00:00:00.000Z","updated":"2020-07-06T12:36:52.000Z","comments":true,"path":"2017/04/20/Demo/","permalink":"https://blog.kurenai.moe/2017/04/20/Demo/","excerpt":"test test！！","text":"test test！！ ACG格子裙赛高！ カントク - COLORS(id=47646872)","categories":[{"name":"ACG","slug":"ACG","permalink":"https://blog.kurenai.moe/categories/ACG/"}],"tags":[{"name":"监督","slug":"监督","permalink":"https://blog.kurenai.moe/tags/%E7%9B%91%E7%9D%A3/"},{"name":"格子裙","slug":"格子裙","permalink":"https://blog.kurenai.moe/tags/%E6%A0%BC%E5%AD%90%E8%A3%99/"},{"name":"放学五年目","slug":"放学五年目","permalink":"https://blog.kurenai.moe/tags/%E6%94%BE%E5%AD%A6%E4%BA%94%E5%B9%B4%E7%9B%AE/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-20T00:00:00.000Z","updated":"2019-08-11T14:03:03.000Z","comments":true,"path":"2017/03/20/hello-world/","permalink":"https://blog.kurenai.moe/2017/03/20/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"tags","slug":"tags","permalink":"https://blog.kurenai.moe/tags/tags/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"https://blog.kurenai.moe/categories/%E7%BC%96%E7%A8%8B/"},{"name":"Game","slug":"Game","permalink":"https://blog.kurenai.moe/categories/Game/"},{"name":"折腾记录","slug":"折腾记录","permalink":"https://blog.kurenai.moe/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"},{"name":"Java","slug":"Java","permalink":"https://blog.kurenai.moe/categories/Java/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://blog.kurenai.moe/categories/Kotlin/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://blog.kurenai.moe/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"Reactor","slug":"Java/Reactor","permalink":"https://blog.kurenai.moe/categories/Java/Reactor/"},{"name":"docker","slug":"docker","permalink":"https://blog.kurenai.moe/categories/docker/"},{"name":"ACG","slug":"ACG","permalink":"https://blog.kurenai.moe/categories/ACG/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://blog.kurenai.moe/tags/JPA/"},{"name":"Gameplay","slug":"Gameplay","permalink":"https://blog.kurenai.moe/tags/Gameplay/"},{"name":"鸣潮","slug":"鸣潮","permalink":"https://blog.kurenai.moe/tags/%E9%B8%A3%E6%BD%AE/"},{"name":"Wuthering Waves","slug":"Wuthering-Waves","permalink":"https://blog.kurenai.moe/tags/Wuthering-Waves/"},{"name":"黑神话","slug":"黑神话","permalink":"https://blog.kurenai.moe/tags/%E9%BB%91%E7%A5%9E%E8%AF%9D/"},{"name":"Black Myth","slug":"Black-Myth","permalink":"https://blog.kurenai.moe/tags/Black-Myth/"},{"name":"GraalVM","slug":"GraalVM","permalink":"https://blog.kurenai.moe/tags/GraalVM/"},{"name":"Java","slug":"Java","permalink":"https://blog.kurenai.moe/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://blog.kurenai.moe/tags/Kotlin/"},{"name":"Gradle","slug":"Gradle","permalink":"https://blog.kurenai.moe/tags/Gradle/"},{"name":"协程","slug":"协程","permalink":"https://blog.kurenai.moe/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"J.U.C","slug":"J-U-C","permalink":"https://blog.kurenai.moe/tags/J-U-C/"},{"name":"MQ","slug":"MQ","permalink":"https://blog.kurenai.moe/tags/MQ/"},{"name":"Micro Service","slug":"Micro-Service","permalink":"https://blog.kurenai.moe/tags/Micro-Service/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.kurenai.moe/tags/Redis/"},{"name":"ウマ娘","slug":"ウマ娘","permalink":"https://blog.kurenai.moe/tags/%E3%82%A6%E3%83%9E%E5%A8%98/"},{"name":"ORM","slug":"ORM","permalink":"https://blog.kurenai.moe/tags/ORM/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://blog.kurenai.moe/tags/Hibernate/"},{"name":"Reactor","slug":"Reactor","permalink":"https://blog.kurenai.moe/tags/Reactor/"},{"name":"Webflux","slug":"Webflux","permalink":"https://blog.kurenai.moe/tags/Webflux/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.kurenai.moe/tags/Spring/"},{"name":"DDD","slug":"DDD","permalink":"https://blog.kurenai.moe/tags/DDD/"},{"name":"CQRS","slug":"CQRS","permalink":"https://blog.kurenai.moe/tags/CQRS/"},{"name":"Event Sourcing","slug":"Event-Sourcing","permalink":"https://blog.kurenai.moe/tags/Event-Sourcing/"},{"name":"docker","slug":"docker","permalink":"https://blog.kurenai.moe/tags/docker/"},{"name":"ops","slug":"ops","permalink":"https://blog.kurenai.moe/tags/ops/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.kurenai.moe/tags/Nginx/"},{"name":"转载","slug":"转载","permalink":"https://blog.kurenai.moe/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"三秋 缒","slug":"三秋-缒","permalink":"https://blog.kurenai.moe/tags/%E4%B8%89%E7%A7%8B-%E7%BC%92/"},{"name":"摘抄","slug":"摘抄","permalink":"https://blog.kurenai.moe/tags/%E6%91%98%E6%8A%84/"},{"name":"小说","slug":"小说","permalink":"https://blog.kurenai.moe/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"监督","slug":"监督","permalink":"https://blog.kurenai.moe/tags/%E7%9B%91%E7%9D%A3/"},{"name":"格子裙","slug":"格子裙","permalink":"https://blog.kurenai.moe/tags/%E6%A0%BC%E5%AD%90%E8%A3%99/"},{"name":"放学五年目","slug":"放学五年目","permalink":"https://blog.kurenai.moe/tags/%E6%94%BE%E5%AD%A6%E4%BA%94%E5%B9%B4%E7%9B%AE/"},{"name":"tags","slug":"tags","permalink":"https://blog.kurenai.moe/tags/tags/"}]}